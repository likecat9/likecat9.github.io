<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试总结</title>
    <link href="/2020/12/27/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/27/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试复习内容"><a href="#面试复习内容" class="headerlink" title="面试复习内容"></a>面试复习内容</h1><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>object类主要方法有：</p><ul><li><p>clone</p><p>创建并返回此对象的一个副本。</p></li><li><p>equals</p><p>判断其他对象与此对象是否相等，默认情况下比较的是地址。当此方法被重写时，有必要重写hashCode方法，以维护hashCode方法的常规协定，即相等对象必须有相等的哈希码。</p></li><li><p>finalize</p><p>当垃圾回收器确定不存在对该对象的更多引用时，由该对象的垃圾回收期调用此方法。</p></li><li><p>getClass</p><p>获取当前运行时的类对象。</p></li><li><p>hashCode</p><p>返回该对象的哈希码。</p></li><li><p>notify</p><p>随机唤醒一个在此对象监视器上等待的单个线程。</p></li><li><p>notifyAll</p><p>唤醒此对象监视器上所有等待的线程。</p></li><li><p>toString</p></li><li><p>wait X3</p><p>使当前线程进入阻塞状态，放弃锁，直到此对象的notify唤醒。</p></li></ul><h5 id="equals和-的区别？"><a href="#equals和-的区别？" class="headerlink" title="equals和==的区别？"></a>equals和==的区别？</h5><ul><li>==：基础类型比较的是值，引用类型比较的是地址。</li><li>equals：默认比较对象的地址，可以重写。</li></ul><p>基础类型：byte、short、int、long、float、double、char、boolean。</p><p>引用类型：如数组、String、对象等。</p><h5 id="equals和hashcode的关系？"><a href="#equals和hashcode的关系？" class="headerlink" title="equals和hashcode的关系？"></a>equals和hashcode的关系？</h5><p>equals相等则hashCode一定相等、hashCode相等而equals不一定相等。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><h5 id="String、StringBuffer和StringBuilder的区别？"><a href="#String、StringBuffer和StringBuilder的区别？" class="headerlink" title="String、StringBuffer和StringBuilder的区别？"></a>String、StringBuffer和StringBuilder的区别？</h5><p>String：不可修改的对象，每次修改都会生成新的对象。String的对象实际上是对在方法区中的字符串的引用，如 String s=“abc”; 会在方法区生成一个abc的字符串，s是该字符串的引用；再运行 s=“def”; 则会在方法区生成一个def字符串，s改为def的引用。</p><p>StringBuffer：可变对象，非线程安全。</p><p>StringBuilder：可变对象，线程安全。</p><p>使用效率：StringBuilder大于StringBuffer大于String。</p><h4 id="继承–面向对象的特性"><a href="#继承–面向对象的特性" class="headerlink" title="继承–面向对象的特性"></a>继承–面向对象的特性</h4><h5 id="Java中抽象类和接口的特点？"><a href="#Java中抽象类和接口的特点？" class="headerlink" title="Java中抽象类和接口的特点？"></a>Java中抽象类和接口的特点？</h5><p>共同点：</p><ol><li>都是作为上层使用，定义抽象方法，成为某种规范。</li><li>都不能直接对其进行实例化。</li></ol><p>不同点：</p><ol><li>抽象类可以有属性和成员方法，接口不行。</li><li>一个类只能继承一个抽象方法，而可以实现多个接口。</li><li>抽象类的变量可以是普通变量，而接口中只能有静态变量。</li></ol><h5 id="关于多态的理解？"><a href="#关于多态的理解？" class="headerlink" title="关于多态的理解？"></a>关于多态的理解？</h5><p>多态是面对对象编程的特性之一（继承、封装和多态），允许不同类对同一事件进行响应。</p><p>使用多态：继承一个类，重写父类的方法，使用父类引用指向一个子类对象。</p><p>实现方式：接口、重写父类方法和重载方法。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>list接口已经声明了所有方法。</p><p>常用实现类：ArrayList、LinkedList。</p><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>数组实现的一个列表，可以存入空元素，允许重复元素，有序，非线程安全。默认容量为10，填满后下一次添加元素时扩容，每次扩容为原来的1.5倍。</p><h5 id="ArrayList与LinkedList的区别？"><a href="#ArrayList与LinkedList的区别？" class="headerlink" title="ArrayList与LinkedList的区别？"></a>ArrayList与LinkedList的区别？</h5><ol><li>ArrayList基于数组实现，LinkedList基于链表。</li><li>ArrayList的随机访问效率高于LinkedList，ArrayList可以用数组下标访问元素，而LinkedList需要移动链表指针。</li><li>对于新增和删除操作以及扩容问题LinkedList优于ArrayList，ArrayList在扩容时移动整个数组元素。</li></ol><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>不包含重复元素的集合，即e1.equals(e2)不成立。</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>基于HashMap实现，允许空元素、不允许重复对象、非有序、非线程安全的集合。默认容量16。HashSet中的HashMap中Key为元素，value为定义的一个Object常量。</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>基于TreeMap实现，允许空元素、不允许重复对象、非有序、非线程安全的集合。</p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map中的元素成对存在，即每一个元素由一个键值对组成，其Key不能重复，值可以重复。</p><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>基于哈希表实现，非有序，非线程安全。</p><p>存储过程：</p><ol><li>通过哈希值确定位置。</li><li>如果该位置没有节点，直接存放。</li><li>如果该节点冲突，遍历该节点及后续的节点比较Key的值，如果相等则覆盖。</li><li>新增节点，默认使用链表，相连节点超过8时，在JDK1.8中变为红黑树。</li><li>长度总是2的幂。</li></ol><h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><p>线程安全的哈希表，其元素也是键值对。因为在put操作时使用的是Synchronized关键字锁住整个对象，所以效率低下。</p><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p>HashMap的子类，由哈希表+链表实现，链表保证了其有序，非线程安全。</p><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><p>线程安全的HashMap。元素不可为空。</p><ul><li>JDK1.7中使用分段锁机制，其内部保存一个Segment数组将Map分段，在put时首先使用哈希算法定位到元素属于哪个Segment，然后使用ReentrantLock重入锁锁住该Segment对象，所以可以多线程对Map进行put操作，但受制于Segment的长度。</li><li>JDK1.8中使用数组+链表/红黑树实现，数组为哈希表头、链表存储数据、红黑树结构优化链表遍历速度。其线程安全由CAS原子操作、volatile、synchronized重入锁实现。CAS原子操作即操作的原子性。</li></ul><h5 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h5><p>存储键值对，使用两个数组保存，一个保存key，一个保存value。适用于Key为整形，数据量较小的情况。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>在泛型的使用中，将操作的数据类型作为一个参数，用于接口、类和方法中，即泛型接口、泛型类和泛型方法。</p><p>它提高了类型安全，避免不必要的类型强转，提升了可读性。</p><p>泛型在编译后会被擦除。</p><h3 id="JAVA进阶"><a href="#JAVA进阶" class="headerlink" title="JAVA进阶"></a>JAVA进阶</h3><h4 id="JAVA并发"><a href="#JAVA并发" class="headerlink" title="JAVA并发"></a>JAVA并发</h4><h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><ul><li>New：新建状态。</li><li>Runnable：可运行状态，一旦调用start方法，线程就处于Runnable状态，是否运行取决于CPU。</li><li>Blocked：阻塞状态。</li><li>Waiting：等待状态。</li><li>Timed Waiting：超时等待状态。</li><li>Terminated：终止状态。</li></ul><h5 id="Sleep与Wait的区别？"><a href="#Sleep与Wait的区别？" class="headerlink" title="Sleep与Wait的区别？"></a>Sleep与Wait的区别？</h5><p>wait进入阻塞等待被唤醒，并且释放锁；Sleep超时等待，阻塞线程超时后自动被唤醒，不释放锁。</p><h5 id="进程与线程的区别？"><a href="#进程与线程的区别？" class="headerlink" title="进程与线程的区别？"></a>进程与线程的区别？</h5><p>一个程序就是一个进程，一个进程可以有多个线程，线程是轻量级进程，它拥有自己的堆栈，可以访问共享的内存变量。</p><h5 id="与新建一个线程相比，线程池的好处？"><a href="#与新建一个线程相比，线程池的好处？" class="headerlink" title="与新建一个线程相比，线程池的好处？"></a>与新建一个线程相比，线程池的好处？</h5><p>可以重复利用，节省CPU资源和重新创建线程的时间，使线程可控。</p><h5 id="讲一讲线程池ThreadPoolExecutor构造参数的含义？"><a href="#讲一讲线程池ThreadPoolExecutor构造参数的含义？" class="headerlink" title="讲一讲线程池ThreadPoolExecutor构造参数的含义？"></a>讲一讲线程池ThreadPoolExecutor构造参数的含义？</h5><ul><li>corePoolSize：核心线程数量。</li><li>maximumPoolSize：最大线程数量，包括corePoolSize。</li><li>keepAliveTime：线程最大空闲存活时间。</li><li>unit：存活时间的单位。</li><li>workQueue：阻塞队列，存放任务。</li></ul><h5 id="常用的线程池有哪些？"><a href="#常用的线程池有哪些？" class="headerlink" title="常用的线程池有哪些？"></a>常用的线程池有哪些？</h5><ul><li>Executors.newFixedThreadPool：可重用固定线程数的线程池，其内部全是核心线程且数量固定，使用的是LinkedBlockingQueue阻塞队列，该阻塞队列由链表实现。</li><li>Executors.SingleThreadPool：单一核心线程的线程池，能确保所有任务在一个线程中顺序执行，使用的阻塞队列是LinkedBlockingQueue。</li><li>Executors.CachedThreadPool：根据需要创建线程的线程池，没有核心线程，使用的是SynchronousQueue阻塞队列，该阻塞队列不存储元素，插入后的下一次插入必须先让之前插入的元素出列后才能进行插入。</li><li>Executors.ScheduledThreadPool：可定时和重复执行的线程池，使用的阻塞队列是DelayedWorkQueue。</li></ul><h5 id="常见的阻塞队列有哪些？"><a href="#常见的阻塞队列有哪些？" class="headerlink" title="常见的阻塞队列有哪些？"></a>常见的阻塞队列有哪些？</h5><ul><li>ArrayBlockingQueue：数组结构的阻塞队列。</li><li>LinkedBlockingQueue：链表结构的阻塞队列。</li><li>SynchronousQueue：不保存的阻塞队列。</li><li>PriorityBlockingQueue：按优先级排序的阻塞队列。</li></ul><h5 id="讲一讲线程池的运行流程？"><a href="#讲一讲线程池的运行流程？" class="headerlink" title="讲一讲线程池的运行流程？"></a>讲一讲线程池的运行流程？</h5><p>当新任务进入线程池后，线程池判断当前核心线程数是否已满，是则判断任务队列容量，否则用核心线程执行任务；判断任务队列是否已满，是则判断当前线程数量是否已满，否则将任务加入任务队列；判断当前线程数量是否已满，是则执行饱和策略，否则创建非核心线程执行任务。</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>多个线程同时被阻塞，它们的一个或全部在等待某个资源被释放。由于线程被无限期阻塞，程序无法正常终止。</p><p>产生死锁的4个必要条件：</p><ol><li>互斥使用：当资源被一个线程占用时，其他线程无法占用该资源。</li><li>不可抢占：资源占有者的资源不能被其他线程抢走，只能等待其释放资源。</li><li>请求和保持：资源占有者在占有资源的同时请求其他资源。</li><li>循环等待：存在一个等待队列：p1占有p2资源、p2占有p3资源、p3占有p1资源。</li></ol><h5 id="Synchronized关键字的使用？"><a href="#Synchronized关键字的使用？" class="headerlink" title="Synchronized关键字的使用？"></a>Synchronized关键字的使用？</h5><ol><li>修饰方法：被修饰的方法同一时间只能有一个线程访问。</li><li>同步代码块：锁住对象的对象锁，每个线程只能拿到该对象的对象锁才能进入代码块。</li></ol><h5 id="Synchronized锁对象与锁Class的区别？"><a href="#Synchronized锁对象与锁Class的区别？" class="headerlink" title="Synchronized锁对象与锁Class的区别？"></a>Synchronized锁对象与锁Class的区别？</h5><p>锁Class的情况下，无论多线程访问的是哪一个实例，都是串行；而锁对象则是多线程访问同一对象串行，不同对象并行。</p><h5 id="Synchronized同步原理？"><a href="#Synchronized同步原理？" class="headerlink" title="Synchronized同步原理？"></a>Synchronized同步原理？</h5><p>对象都有一个monitor对象锁，线程会获取该monitor对象锁，实现同步；</p><h5 id="Synchronized与Lock的区别？"><a href="#Synchronized与Lock的区别？" class="headerlink" title="Synchronized与Lock的区别？"></a>Synchronized与Lock的区别？</h5><ol><li>一个是关键字，一个是接口。</li><li>Synchronized遇到异常直接释放锁，Lock需要调用unlock释放锁。</li><li>lock可中断，Synchronized不能中断。</li><li>Synchronized不能尝试获取锁，lock可以尝试获取锁。</li></ol><h5 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h5><p>乐观锁：每次不加锁，假设在修改共享数据时其他线程不会修改此数据，如果发生冲突直接重试，直到成功为止。典型为CAS原子性操作，以atomic为代表的一系列类。</p><p>悲观锁：假设在修改共享数据时，其他线程也会修改此数据，所以线程会等待锁的释放。典型为Synchronized和ReentrantLock。</p><h5 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h5><p>CAS即比较与交换，CAS操作包含3个操作数：内存位置、预期原值和新值，如果内存位置的值与预期原值相匹配，则更新为新值，否则不进行任何操作。其底层是JVM调用本地方法实现原子性操作。</p><h5 id="JAVA中的原子性、可见性和有序性分别是什么？"><a href="#JAVA中的原子性、可见性和有序性分别是什么？" class="headerlink" title="JAVA中的原子性、可见性和有序性分别是什么？"></a>JAVA中的原子性、可见性和有序性分别是什么？</h5><p>原子性：即对共享变量的操作要么全部执行，买么全部不执行。</p><p>可见性：一个线程对共享变量进行修改后，另一个线程立即可见。</p><p>有序性：JAVA语言允许编译器和处理器在不改变结果的情况下对指令进行重排序。</p><h5 id="对volatile的了解有多少？"><a href="#对volatile的了解有多少？" class="headerlink" title="对volatile的了解有多少？"></a>对volatile的了解有多少？</h5><p>volatile保证了可见性与有序性，不保证原子性。</p><h4 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h4><h5 id="Java内存区域是如何划分的？"><a href="#Java内存区域是如何划分的？" class="headerlink" title="Java内存区域是如何划分的？"></a>Java内存区域是如何划分的？</h5><ul><li>程序计数器：用于指示当前线程的字节码执行位置。</li><li>Java虚拟机栈：存放Java方法相关数据，如局部变量。</li><li>本地方法栈：存放本地方法，如C++等底层代码。</li><li>Java堆：保存所有对象的实例。</li><li>方法区：存放类信息、静态变量和常量等。</li></ul><h5 id="如何判断对象可回收？"><a href="#如何判断对象可回收？" class="headerlink" title="如何判断对象可回收？"></a>如何判断对象可回收？</h5><p>Java通过可达性算法判断对象是否可回收，可达性算法通过一系列GC Root节点，自上而下关联所有的引用，串成引用链，当一个对象没有和任何引用链相关联时，即可回收。</p><h5 id="GC的常用算法？"><a href="#GC的常用算法？" class="headerlink" title="GC的常用算法？"></a>GC的常用算法？</h5><ul><li>标记-清除：先标记所有需要回收的对象，然后统一回收所有被标记的对象。</li><li>分代算法：根据对象存活的周期，Java堆会分为新生代和老年代，根据不同的特性选择回收算法。</li></ul><h5 id="四种引用即区别是什么？"><a href="#四种引用即区别是什么？" class="headerlink" title="四种引用即区别是什么？"></a>四种引用即区别是什么？</h5><ul><li>强引用：只要强引用在，就不会被回收。</li><li>软引用：在内存不足时会被回收。</li><li>弱引用：只要JVM开始回收内存，就会被回收。</li><li>虚引用：必须和引用队列一起使用，该引用对象随时会被回收。</li></ul><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><h5 id="类加载的过程？"><a href="#类加载的过程？" class="headerlink" title="类加载的过程？"></a>类加载的过程？</h5><ol><li>加载：从二进制流转换为对应的类型信息，从而生成一个Class对象。</li><li>连接<ol><li>验证：检查Class字节流包含的信息符合当前虚拟机的要求。</li><li>准备：为静态变量分配内存地址并赋值（默认值）。</li><li>解析：引用内存地址。</li></ol></li><li>初始化：为静态变量赋值（定义的值）。</li><li>使用</li><li>卸载</li></ol><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><h5 id="Activity生命周期？"><a href="#Activity生命周期？" class="headerlink" title="Activity生命周期？"></a>Activity生命周期？</h5><ul><li>onCreate：此时Activity不可见，不可交互，常用语初始化View。</li><li>onRestart</li><li>onStart：此时Activity可见，不可交互，此方法会在从暂停状态到活动状态后调用，会被多次被调用。</li><li>onResume：此时Activity可见，可交互，可以在此时执行开启动画或者打开相机等操作，Activity重新可见即会调用此方法。</li><li>onPause：此时Activity可见，不可交互，当Activity失去焦点时调用此方法，在一个Activity中启动另一个Activity后，新的Activity会等待该Activity的onPause方法走完才会进入onCreate方法。</li><li>onStop：此时Activity不可见，不可交互，当Activity完全不可见、App进入后台等时调用，之后要么走onDestroy要么走onRestart-&gt;onStart-&gt;onResume。</li><li>onDestroy：Activity销毁前会调用此方法，常用语释放资源。</li></ul><h5 id="当一个Activity启动一个新的Activity它们的生命周期方法是怎样的？"><a href="#当一个Activity启动一个新的Activity它们的生命周期方法是怎样的？" class="headerlink" title="当一个Activity启动一个新的Activity它们的生命周期方法是怎样的？"></a>当一个Activity启动一个新的Activity它们的生命周期方法是怎样的？</h5><p>A：onPause，B：onCreate，B：onStart，B：onResume，A：onStop</p><h5 id="如果屏幕旋转Activity生命周期方法如何调用？"><a href="#如果屏幕旋转Activity生命周期方法如何调用？" class="headerlink" title="如果屏幕旋转Activity生命周期方法如何调用？"></a>如果屏幕旋转Activity生命周期方法如何调用？</h5><p>屏幕旋转Activity会被销毁，并重新打开Activity。</p><p>onPause，onStop，onDestroy，onCreate，onStart，onResume。</p><h5 id="Activity四种启动模式了解多少？"><a href="#Activity四种启动模式了解多少？" class="headerlink" title="Activity四种启动模式了解多少？"></a>Activity四种启动模式了解多少？</h5><ul><li>Standard：默认模式，每次启动该Activity都会在任务栈中创建一个该Activity的实例。</li><li>SingleTop：栈顶复用模式，启动该Activity时如果该Activity在栈顶则直接使用该Activity，并调用onNewIntent方法；不在栈顶则创建新的Activity实例。</li><li>SingleTask：栈内复用模式，启动该Activity时如果该栈内存在该Activity的实例，则直接复用，调用onNewIntent方法，并将其上面的所有Activity出栈。</li><li>SingleInstance：全局唯一模式，该Activity会拥有和SingleTask一样的特性并且独占整个栈。</li></ul><h5 id="Activity的启动模式有哪些？"><a href="#Activity的启动模式有哪些？" class="headerlink" title="Activity的启动模式有哪些？"></a>Activity的启动模式有哪些？</h5><ul><li><p>显式</p><p>直接startActivity，new一个Intent设置要跳转的Activity的Class。</p></li><li><p>隐式</p><p>startActivity，new一个Intent，不需要设置要跳转的Class，而是设置Intent的Action为Intent.ACTION_VIEW，或者设置为自定义的字段。其中如果设置为ACTION_VIEW则时调用如电话簿等Activity，需要设置Intent的data；如果设置为自定义的字段，则该字段应该和目标Activity的intent-filter中的action字段匹配，并且需要加上category为default，否则会抛出异常。</p></li></ul><h5 id="Activity的启动流程了解多少？"><a href="#Activity的启动流程了解多少？" class="headerlink" title="Activity的启动流程了解多少？"></a>Activity的启动流程了解多少？</h5><p>首先从Main方法进入，创建一个ActivityThread类，该类调用attch方法通知ActivityManagerService进行创建Application之前的初始化操作（使用binder进行进程间通信），开始循环等待消息。</p><p>当ActivityManagerService完成创建Application之前的所有准备工作后会发送可以创建Application的消息，在主线程的主Handler中处理该消息。</p><p>主Handler中调用handleBindApplication方法创建Application，还会创建一个Instrumentation，该类是辅助类用于调用Activity生命周期及其他事务。</p><p>主Handler中调用handleLuanchActivity方法，使用Instrumentation辅助对象创建Activity，再使用该对象调用Activity的onCreate方法，在onCreate方法中会通过setContentView创建一个DecorView，并解析传入的xml Id，将解析后的view放入DecorView中，此时DecorView没有加载到WindowManager中。</p><p>然后会调用handleResumeActivity，该方法会先回调Activity的onResume方法，然后再将DecorView传入WindowManger。</p><p>WindowManager会创建一个ViewRootImpl，将DecorView放入此root中，然后请求第一次绘制。</p><h5 id="打开一个APP的启动流程是什么？"><a href="#打开一个APP的启动流程是什么？" class="headerlink" title="打开一个APP的启动流程是什么？"></a>打开一个APP的启动流程是什么？</h5><p>当一个APP被点击时，首先要和zygote建立socket连接，将创建进程需要的参数发送给zygote，zygote接收到参数后fork出一个进程，通过findStaticMain方法找到ActivityThread的main方法并调用。</p><h5 id="binder了解多少？"><a href="#binder了解多少？" class="headerlink" title="binder了解多少？"></a>binder了解多少？</h5><p>binder是Android独有的跨进程通信组件，其使用内存映射的方式修改数据效率更高，安全性好。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h5 id="Service的启动方式有哪些？"><a href="#Service的启动方式有哪些？" class="headerlink" title="Service的启动方式有哪些？"></a>Service的启动方式有哪些？</h5><ul><li>Started：从其他组件调用startService启动一个Service，该方法启动的Service会一直存在于后台，直到自己调用stopSlef或者其他组件调用stopService。</li><li>Bind：其他组件调用bindService来绑定一个Service，该Service会随着被绑定的组件销毁而销毁；一个Service可以被多个组件绑定，只有所有绑定了该Service的组件调用了unBind才会销毁该Service。</li></ul><h5 id="IntentService和Service的区别？"><a href="#IntentService和Service的区别？" class="headerlink" title="IntentService和Service的区别？"></a>IntentService和Service的区别？</h5><p>在Service中执行耗时操作需要新建一个线程，而IntentService默认开了一个子线程，在onHandleIntent方法中处理intent传来的数据，因为会顺序执行指令不用担心多线程问题，并且会在所有请求完成后自动停止该Service。</p><h3 id="消息机制-Handler相关"><a href="#消息机制-Handler相关" class="headerlink" title="消息机制 Handler相关"></a>消息机制 Handler相关</h3><h5 id="Android消息机制了解多少？"><a href="#Android消息机制了解多少？" class="headerlink" title="Android消息机制了解多少？"></a>Android消息机制了解多少？</h5><p>Android是基于消息机制的，其核心是不停地从消息队列中取消息，保证App能正常运行，当这个取消息的循环结束那么App也就退出了。详细一点就是在ActivityThread中启动了一个Looper，它先保证该线程只会存在一个Looper和消息队列，即在prepareMainLooper方法中创建一个Looper该Looper中有一个消息队列（MessageQueue），并将该Looper放入当前线程的ThreadLocal中。然后获取当前线程的Handler，然后开始循环取消息并发送到Handler的dispatchMessage进行处理。</p><h5 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h5><p>ThreadLocal是线程的本地变量，在Java的Thread中的ThreadLocal是由一个ThreadLocalMap实现，该Map底层是一个ThreadLocal数组，ThreadLocal是一个弱引用，该ThreadLocal类中有一个Object保存数据。</p><h5 id="如何处理Handler的内存泄漏问题？"><a href="#如何处理Handler的内存泄漏问题？" class="headerlink" title="如何处理Handler的内存泄漏问题？"></a>如何处理Handler的内存泄漏问题？</h5><p>将Handler对上下文或者Activity的引用改为弱引用，将内部类改为静态内部类。对于延时消息，在界面关闭后调用removeCallbacksAndMessages方法移除消息。</p><h5 id="怎么创建Message对象？"><a href="#怎么创建Message对象？" class="headerlink" title="怎么创建Message对象？"></a>怎么创建Message对象？</h5><p>使用Message.onbtain方法或者Handler.obtainMessage方法。</p><h5 id="什么是同步屏障？有使用过吗？"><a href="#什么是同步屏障？有使用过吗？" class="headerlink" title="什么是同步屏障？有使用过吗？"></a>什么是同步屏障？有使用过吗？</h5><p>Handler同步屏障即阻断消息队列中的同步消息的执行，提供了消息队列的优先级操作的方式，开启了同步屏障后，只会执行异步消息。</p><p>开启同步屏障需要通过反射。</p><p>使用反射创建Handler的时候传入true或者使用message.setAynchronous(true); [eɪˈsɪŋkrənəs] 方法设为异步消息。</p><h3 id="View相关"><a href="#View相关" class="headerlink" title="View相关"></a>View相关</h3><h5 id="Android事件分发流程？"><a href="#Android事件分发流程？" class="headerlink" title="Android事件分发流程？"></a>Android事件分发流程？</h5><p>当手指与屏幕交互时，Android系统会创建一个MotionEvent对象对交互事件进行封装，该MotionEvent在View之间传递的过程就是事件分发过程。</p><p>事件由Window向下传递，从根ViewGroup开始，在ViewGroup中的dispatchTouchEvent分发中根据onInterceptTouchEvent方法的返回值对该事件进行拦截，如果拦截，则进入View的onTouchEvent方法，如果不拦截则遍历子元素，从最上层的子View开始，调用它们的dispatchTouchEvent方法，如果该View是ViewGroup则会重复此操作直到底层View，调用底层View的dispatchTouchEvent方法，该View的dispatchTouchEvent方法又会判断触摸事件、点击事件等，最后会调用该View的onTouchEvent方法。</p><p>从底层View开始如果onTouchEvent方法不为true（即消费该事件），则会向上传递交给父View的onTouchEvent方法处理。</p><h5 id="View的绘制流程？"><a href="#View的绘制流程？" class="headerlink" title="View的绘制流程？"></a>View的绘制流程？</h5><p>View的绘制是从ViewRoot的performTraversals方法开始的，此方法依次调用performMeasure、performLayout和performDraw三个方法，这三个方法会分别完成顶级View的measure、layout和draw流程。</p><p>在performMeasure中会调用measure方法，在measure中又会调用onMeasure方法，在onMeasure中会对所有的子元素进行measure，此时测量流程就从父容器传递到子View中，如此反复最终整个View树都会测量完毕。布局和绘制流程与此类似。</p><h3 id="性能优化相关"><a href="#性能优化相关" class="headerlink" title="性能优化相关"></a>性能优化相关</h3><h5 id="你在工作中有遇到过性能问题吗？是如何解决的？"><a href="#你在工作中有遇到过性能问题吗？是如何解决的？" class="headerlink" title="你在工作中有遇到过性能问题吗？是如何解决的？"></a>你在工作中有遇到过性能问题吗？是如何解决的？</h5><p>有，之前需要重写一个商品详情页面，我是用的是ConstraintLayout约束布局，但还是遇到了开启该页面较慢的情况，我经过测试发现是因为我约束布局的子元素太多导致进入页面慢，我的最开始的想法是通过替换布局来实现快速进入页面，但是如果打开这个页面是白屏然后突然变成全有数据的页面效果也没让我满意，所以我使用了ViewStub，将整个页面进行分块，分成多个ViewStub，进入页面时只将能看见的几个ViewStub转换为布局，其他的部分不进行转换，这大大提高了打开此页面的速度，也达到了我可以接受的水平。</p><h3 id="第三方库相关"><a href="#第三方库相关" class="headerlink" title="第三方库相关"></a>第三方库相关</h3><h4 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h4><h5 id="okhttp怎么发送get请求？"><a href="#okhttp怎么发送get请求？" class="headerlink" title="okhttp怎么发送get请求？"></a>okhttp怎么发送get请求？</h5><p>首先通过Request.Builder对象创建一个Request，然后new一个OKHTTPClient对象，使用client的newCall方法传入request获取call对象，调用call对象的enqueue方法开始异步请求，enqueue方法需要一个CallBack对象，该对象是请求的成功与失败回调。</p><h5 id="okhttp请求流程？"><a href="#okhttp请求流程？" class="headerlink" title="okhttp请求流程？"></a>okhttp请求流程？</h5><p>当调用newCall方法时会返回一个RealCall对象，它是真正发起请求的类。请求Dispatch类进行分发处理，该类有3个队列保存了正在运行的异步请求、准备运行的异步请求和正在运行的同步请求，同时还规定了最大请求数和主机的最大请求数，还有一个线程池。最终线程池的execute方法会开启拦截器链，通过拦截器来对请求分装、转换、请求等操作，最终在execute方法中进行回调。</p><h5 id="应用拦截器和网络拦截器的区别？"><a href="#应用拦截器和网络拦截器的区别？" class="headerlink" title="应用拦截器和网络拦截器的区别？"></a>应用拦截器和网络拦截器的区别？</h5><p>如果把APP、OkHttp和服务器看做三个部分，那么从APP使用OkHttp取服务器读取数据然后返回的流程就是一次请求流程，在APP到OkHttp的过程中的拦截器是应用拦截器，OkHttp到服务器之间的拦截器为网路拦截器。</p><p>应用拦截器不需要关心重定向和重连问题、总是调用一次，可以决定其他拦截器是否调用，可以重试和多次调用Chain.proceed。</p><p>网络拦截器可以观察到所有网络传输的数据，可以操作重定向和重连。</p><h5 id="常见的拦截器有哪些？顺序是什么？"><a href="#常见的拦截器有哪些？顺序是什么？" class="headerlink" title="常见的拦截器有哪些？顺序是什么？"></a>常见的拦截器有哪些？顺序是什么？</h5><p>自定义拦截器，它会最先调用；重试和重定向拦截器；请求、响应转换拦截器，封装请求和响应；缓存拦截器；连接拦截器；从服务器读取响应的拦截器。</p><h5 id="说说okhttp的连接复用？"><a href="#说说okhttp的连接复用？" class="headerlink" title="说说okhttp的连接复用？"></a>说说okhttp的连接复用？</h5><p>okhttp定义了一个ConnectionPool连接池保存了连接对象，避免每次都需要重新建立连接。</p><p>该连接池定义了socket的最大并发连接数和最大空闲存活时间、一个线程池和一个RealConnection双端队列，其内部不断的使用cleanup方法对RealConnection进行清理。</p><p>RealConnection是真正使用socket进行网络连接的对象，该对象内部保存了SteamAllocation引用列表，作为该连接的引用计数，当次列表中的SteamAllocation对象被全部移除后，即没有在使用该连接，也意味着该RealConnection可以被clean。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程与网络框架</title>
    <link href="/2020/12/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/12/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p>从上到下是：</p><ul><li>应用层：HTTP（keepalive connections 保持连接）、FTP、邮件等协议，它规定了应用程序的数据格式。</li><li>传输层：TCP（可靠面向连接协议）、UDP（不可靠无连接协议），建立主机到主机的通信。</li><li>网络层：该层决定如何将数据从发送方路由到接收方。</li><li>数据链路层：该层控制网络层与物理层之间的通信，保证数据在物理层进行可靠传输（重发帧）。</li><li>物理层：连接计算机的物理手段。</li></ul><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p>建立连接的三次握手</p><ul><li>第一次：客户端发送连接请求报文段，将SYN设为1、seq设为x，客户端进入SYN_SENT状态。</li><li>第二次：服务端确认SYN信息、将SYN设为1、seq设为y、ACK设为x+1，把这些数据打包为SYN+ACK发送给客户端。客户端收到此报文进入建立连接状态。</li><li>第三次：客户端将ACK设为y+1，向服务端发送ACK报文。服务端接受到此报文进入建立连接状态。</li></ul><p>断开连接的四次挥手</p><ul><li>第一次：客户端设置seq和ACK，向服务端发送FIN报文段。</li><li>第二次：服务端收到FIN报文段后，向客户端发送ACK报文段。</li><li>第三次：服务端向客户端发送FIN报文段。</li><li>第四次：客户端接收到FIN报文段后，向服务端发送ACK报文段。服务端收到ACK后就会关闭连接，客户端将不会收到任何回复，客户端关闭连接。</li></ul><h2 id="OKHTTP"><a href="#OKHTTP" class="headerlink" title="OKHTTP"></a>OKHTTP</h2><h4 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h4><p>请求是由OkHttp发出，真实的请求被封装到了RealCall类中，在调用okHttpClient.newCall(request).enqueue时，实际上是创建了一个RealCall，并调用RealCall对象的enqueue方法。（或execute方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Call <span class="hljs-title">newCall</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> RealCall.newRealCall(<span class="hljs-keyword">this</span>, request, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* for web socket */</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>异步请求，构造一个AsyncCall，并将自己放入执行队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> </span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already Executed&quot;</span>);<br>    executed = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  captureCallStackTrace();<br>  eventListener.callStart(<span class="hljs-keyword">this</span>);<br>  client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(responseCallback));<br>&#125;<br></code></pre></td></tr></table></figure><p>同步请求，直接执行，并返回结果。（onFailure、onResponse）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already Executed&quot;</span>);<br>        executed = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    captureCallStackTrace();<br>    eventListener.callStart(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        client.dispatcher().executed(<span class="hljs-keyword">this</span>);<br>        Response result = getResponseWithInterceptorChain();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        eventListener.callFailed(<span class="hljs-keyword">this</span>, e);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种请求都会调用getResponseWithInterceptorChain获取Response。</p><p>Dispatcher调度器用于控制并发的请求，设有最大并发请求数maxRequests （64）、每个主机的最大请求数maxRequestsPerHost （5）、消费者线程池和3个双端队列</p><ul><li>readyAsyncCalls：准备运行的异步请求队列</li><li>runningAsyncCalls：正在运行的异步请求队列</li><li>runningSyncCalls：正在运行的同步请求队列</li></ul><p>同步请求直接将请求添加到runningSyncCalls；异步请求会根据当前正在运行的异步数进行判断，如果正在运行的异步请求队列的大小小于最大并发请求数且同一主机的最大请求数小于每个主机的最大请求数则将请求放入正在运行的异步请求队列，否则，放入准备运行的异步请求队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(AsyncCall call)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;<br>    runningAsyncCalls.add(call);<br>    executorService().execute(call);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    readyAsyncCalls.add(call);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getResponseWithInterceptorChain是真正发起请求的地方，该方法首先构建一个拦截器列表，添加拦截器，然后实例化一个RealInterceptorChain对象将拦截器列表传入该对象，再调用该对象的proceed方法对拦截列表里的拦截器链式调用。</p><p>拦截器列表的添加顺序如下：</p><ol><li>client.interceptors()：自定义拦截器</li><li>RetryAndFollowUpInterceptor：重试和重定向拦截器</li><li>BridgeInterceptor：请求、响应转换拦截器，将用户构造的请求转为发送服务器的请求、将服务器的响应转换为对用户友好的响应</li><li>CacheInterceptor：缓存拦截器，读取、更新缓存</li><li>ConnectInterceptor：连接拦截器，建立与服务器的连接</li><li>CallServerInterceptor：从服务器读取响应的拦截器</li></ol><h5 id="连接池（ConnectionPool）"><a href="#连接池（ConnectionPool）" class="headerlink" title="连接池（ConnectionPool）"></a>连接池（ConnectionPool）</h5><p>频繁的进行建立Sokcet连接（TCP三次握手）和断开Socket（TCP四次分手）是非常消耗网络资源和浪费时间的，HTTP中的keepalive连接对于降低延迟和提升速度有非常重要的作用。复用连接就需要对连接进行管理——连接池。</p><p>OkHttp支持5个并发socket连接，默认keepAlive为5分钟。</p><p>ConnectionPool的组成主要有：一个线程池（无缓存的阻塞队列 SynchronousQueue），空闲的socket最大连接数、socket的keepAlive时间和一个保存RealConnection的双端队列。</p><p>RealConnection队列使用socket进行连接，其保存了一个StreamAllocation引用列表，此列表用于计数。</p><p>Runnable对象：cleanupRunnable负责清理连接。它是一个阻塞操作，先执行清理并返回下次需要清理的间隔时间，调用wait方法释放锁。等到时间到了以后再次执行清理操作并返回间隔时间，循环往复。</p><p>清理的工作是由cleanup方法完成，流程为：1.遍历所有连接（查询连接内部StreamAllocation的引用数量、标记不活跃连接），2.开始判断：如果空闲连接超过5个或者keepAlive时间大于5分钟则将该连接清理，根据其他条件返回下次清理时间，3.关闭连接，返回时间0，立即再次进行清理。</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>网络框架</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程编程</title>
    <link href="/2020/12/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/12/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程是操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单位， 进程可以被看作程序的实体，同样，它也是线程的容器。即一个进程就是一个程序（如windows中的exe），有多个线程。</p><p>线程是操作系统调度的最小单元，也叫做轻量级进程。在一个进程中可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p><h5 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h5><ul><li>使用多线程可以减少程序的响应事件。</li><li>与进程相比，线程创建和切换开下更小，同事多线程在数据共享方面效率非常高。</li><li>多CPU或者多核计算机本身就具备执行多线程的能力。如果使用单个线程，将无法重复利用计算机资源。</li><li>多线程能简化程序的结构，使程序便于理解和维护。</li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ol><li><p>New：新创建状态。线程被创建，还没有调用start方法。</p></li><li><p>Runnable：可运行状态。一旦调用start方法，线程就处于Runnable状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统。</p></li><li><p>Blocked：阻塞状态。线程被锁阻塞，暂时不活动。</p></li><li><p>Waiting：等待状态。线程暂时不活动，并且不运行任何代码，这消耗最少的资源，直到线程调度器重新激活。</p></li><li><p>Timed waiting：超时等待状态。和等待状态不同的是，它是可以在指定的时间自行返回的。</p></li><li><p>Terminated：终止状态。表示当前线程已经执行完毕。导致线程终止有两种情况：</p><ol><li>run方法执行完毕正常退出。</li><li>因为一个没有捕获的异常而终止了run方法，导致线程进入终止状态。</li></ol></li></ol><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol><li><p>继承Thread类，重写run()方法</p><p> Thread本质也是实现了Runnable接口的一个实例。在调用start方法后并不是立即执行多线程的代码，而是使该线程变为可运行状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: TestThread1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> TestThread1().start();<br></code></pre></td></tr></table></figure></li><li><p>实现Runnable接口，并实现该接口的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: TestThread2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TestThread2()).start();<br></code></pre></td></tr></table></figure></li><li><p>实现Callable接口，重写call()方法</p><p>Callable实际是属于Executor框架中的功能类，Callable比Runnable更加强大</p><ol><li>Callable可以在任务接受后提供一个返回值。</li><li>Callable中的call方法可以抛出异常。</li><li>运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，他提供了检查计算是否完成的方法。可以在一个线程中拿到目标Callable的Future对象，从而对目标线程进行监视。但调用Future的get方法当前线程就会阻塞，直到call方法返回结果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;run : TestCallable&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//调用</span><br>ExecutorService executorService = Executors.newSingleThreadExecutor();<br>        Future&lt;String&gt; future = executorService.submit(<span class="hljs-keyword">new</span> TestCallable());<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: future.get before&quot;</span>);<br>                    Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: &quot;</span> + future.get());<br>                    Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: future.get after&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br></code></pre></td></tr></table></figure></li></ol><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>当线程的run方法执行完毕，或者在方法中出现没有捕获的异常时，线程将终止。</p><p>interrupt[ˌɪntəˈrʌpt]方法可以用来请求中断线程。当一个线程调用interrupt方法时，线程的中断标识将被置位（置为true），线程会不时地检测这个中断标识位，以判断线程是否应该被中断。想要知道线程是否被置位，调用<code>Thread.currentThread().isInterrupted()</code>。我们可以通过该方法控制进程中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> i;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            i++;<br>            Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: i=&quot;</span> + i);<br>        &#125;<br>        Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: stop&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该Runnable不停输出数字，当该线程收到interrupt中断指令时，就会stop，让该线程输出10ms后停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TestRunnable());<br>        thread.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        thread.interrupt();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>上面有个InterruptedException，该异常是线程检测中断标识时抛出的。即如果一个线程被阻塞（Sleep），就无法检测中断状态。如果一个线程处于阻塞状态，线程在检测中断标识位时如果发现中断标识位为true，则会在阻塞方法调用处抛出InterruptedException异常，并且在抛出异常前将线程的中断标识复位为false。</p><p>比如，修改TestRunnable让它每一秒输出一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> i;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                Thread.currentThread().interrupt();<br>            &#125;<br>            i++;<br>            Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: i=&quot;</span> + i);<br>        &#125;<br>        Log.d(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;run: stop&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在try-catch中不调用Thread.currentThread().interrupt()设置该线程中断标识（true），那么，该线程将不会停止。因为该线程的interrupt标识在调用thread.interrupt()方法时阻塞，抛出了InterruptedException异常，又将interrupt置为false。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在多线程同时读写同一对象时，可能出现的数据错乱问题，所以需要同步来解决，即锁。</p><h4 id="synchronized-ˈsɪŋkrənaɪzd-和重入锁ReentrantLock-rɪˈentrənt"><a href="#synchronized-ˈsɪŋkrənaɪzd-和重入锁ReentrantLock-rɪˈentrənt" class="headerlink" title="synchronized[ˈsɪŋkrənaɪzd]和重入锁ReentrantLock[rɪˈentrənt]"></a>synchronized[ˈsɪŋkrənaɪzd]和重入锁ReentrantLock[rɪˈentrənt]</h4><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p>重入锁ReenrtantLock，支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Lock mLock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reentrant</span><span class="hljs-params">()</span> </span>&#123;<br>    mLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//todo ...</span><br>        <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一结构确保任何时刻只有一个线程进入临界区，临界区就是同一时刻只能有一个任务访问的代码区。</p><p>可以使用Condition condition = mLock.newCondition()获取该锁的条件对象，condition.await()会阻塞当前线程并释放锁，直到另一个线程使用相同的条件对象（condition）的signalAll（激活所有线程）方法重新激活，否则会死锁。该对象还有个signal方法可以随机激活一个线程。</p><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>Java中的每一个对象都有一个内部锁，如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>也可以使用synchronized同步代码块来获取对象上的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><p>Java中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此，它存在内存可见性的问题。而局部变量、方法定义的参数则不会再线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。Java内存模型定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程共享变量的副本，它涵盖了缓存、写缓冲区、寄存器等区域。Java内存模型控制了线程之间的通信。</p><p><img src="https://tvax2.sinaimg.cn/large/007ghrgxgy1glqyb13yecj30mk0acgml.jpg" alt="java内存模型"></p><p>线程A与线程B通信的步骤：</p><ol><li>线程A把线程A本地内存中更新过得共享变量刷新到主存中去。</li><li>线程B到主存中去读取线程A更新过的共享变量。</li></ol><h4 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h4><ol><li><p>原子性</p><p>对基本数据类型的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行完毕，要么不执行。如：<code>x = 3</code></p></li><li><p>可见性</p><p>线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。如共享变量被volatile修饰时，它会保证修改的值被立即刷新到主存。</p></li><li><p>有序性</p><p>Java内存模型中允许编译器和处理器对指令进行重排序，重排序过程会影响到多线程并发执行的正确性。</p></li></ol><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>volatile关键字为实例域的同步访问提供了免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能别另一个线程并发更新的。</p><p>该关键字保证了可见性与有序性，不保证原子性。</p><p>被修饰的变量的更新值，另一个线程立即可见；volatile能禁止指令重排序，在进行指令优化时，在volatile变量之前的语句不能在volatile变量后面执行，同样，在volatile变量之后的语句也不能在volatile变量之前执行。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><h5 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h5><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞，直到有数据放入队列。</li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞，直到队列中有空的位置，线程被自动唤醒。</li></ol><p>支持以上两种阻塞场景的队列被称为阻塞队列。</p><h4 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h4><ol><li><p>ArrayBlockingQueue：由数组结构组成的阻塞队列。</p></li><li><p>LinkedBlockingQueue：由链表结构组成的阻塞队列。</p></li><li><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</p><p>默认情况下元素采取自然顺序升序排列。可以自定义compareTo方法来指定元素排列规则；或者初始化PriorityBlockingQueue时指定构造参数Comparator。</p></li><li><p>DelayQueue：使用优先级队列实现的无界阻塞队列。</p><p>它是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口。创建元素时，可以指定元素到期时间，只有在元素到期时才能从队列中取走。</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列。</p><p>不存储元素的阻塞队列。每个插入操作必须等待另一个线程的移除操作。</p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</p><p>它是由一个链表结构组成的无界阻塞TransferQueue队列。TransferQueue接口的transfer和tryTransfer方法用来传递元素。</p></li><li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列。</p><p>双向队列可以从队列的两端插入和移出元素。</p></li></ol><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>它是用数组实现的有界阻塞队列，并按照先进先出的原则对元素进行排序。默认情况下不保证线程公平地访问队列。（公平访问队列就是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列。即先阻塞的生产者线程，可以先往队列里插入元素；先阻塞的消费者线程，可以先从队列里获取元素。）</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p>它是基于链表的阻塞队列，次队列按照先进先出的原则对元素进行排序，其内部也维持着一个数据缓存队列（链表）。当生产者往队列里放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到缓存容量的最大值时（可以通过构造方法指定），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者会被唤醒。</p><p>LinkedBlockingQueue之所有能够高效地处理并发数据，还因为其对生产者端和消费者端分别采用了独立的锁来控制数据同步。这意味着在高并发的情况下，生产者和消费者可以并行操作队列中的数据。</p><p>需要注意的是：如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量。如果生产者的速度超过消费者的速度，也许还没有等到队列填满进而阻塞生产，系统内存就已经被消耗殆尽。</p><h4 id="阻塞队列的实现原理"><a href="#阻塞队列的实现原理" class="headerlink" title="阻塞队列的实现原理"></a>阻塞队列的实现原理</h4><p>ArrayBlockingQueue为例，内部是个Object数组、队首、队尾元素的下表、元素个数、可重入锁ReentrantLock、notEmpty条件和notFull条件。put判断当前数组长度是否等于元素个数，等待notFull信号，当插入成功后调用notEmpty.signal()唤醒正在等待获取元素的线程；take等待notEmpty信号，拿取后唤醒等待插入的线程。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在Java1.5中提供了Executor框架用于把任务的提交和执行解耦，任务交给Runnable或者Callable，而Executor框架用来处理任务。Executor框架中最核心的成员就是ThreadPoolExecutor[ɪɡˈzekjətər] ，它是线程池的核心实现类。</p><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>可以通过ThreadPoolExecutor来创建一个线程池，其参数最多的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程数。默认情况下线程池是空的，只有任务提交时才会创建线程。如果当前运行的线程数少于corePoolSize，则创建新线程来处理任务；如果等于或多于corePoolSize，则不再创建。如果调用线程池的prestartAllCoreThreads方法，线程会提前创建并启动所有的核心线程来等待任务。</li><li>maximumPoolSize：线程池允许创建的最大线程数。</li><li>keepAliveTime：非核心线程闲置的超时时间。超过这个时间则回收。如果设置allowCoreThreadTimeOut属性为true时，keepAliveTime也会应用到核心线程上。</li><li>unit：keepAliveTime参数的时间单位。</li><li>workQueue：任务队列。如果当前线程数大于corePoolSize，则将任务添加到此任务队列中。</li><li>threadFactory：线程工厂。可以给线程创建名字。</li><li>handler：饱和策略。这是当任务队列和线程池都满了时所采取的应对策略，默认是AbordPolicy（无法处理新任务），并抛出RejectedExecutionException异常。还有其他3种：<ul><li>CallerRunsPolicy:用调用者所在的线程来处理任务。能减缓新任务的提交速度。</li><li>DicardPolicy：不能执行的任务，并将该任务删除。</li><li>DiscardOldestPolicy：丢弃队列最老的未处理请求，并执行当前任务。</li></ul></li></ul><h5 id="线程池的处理流程"><a href="#线程池的处理流程" class="headerlink" title="线程池的处理流程"></a>线程池的处理流程</h5><p>​    <img src="https://tva3.sinaimg.cn/large/007ghrgxgy1gls1dnuaggj30az0qcab0.jpg" alt="线程池的处理流程"></p><h5 id="线程池执行示意图"><a href="#线程池执行示意图" class="headerlink" title="线程池执行示意图"></a>线程池执行示意图</h5><p><img src="https://tva3.sinaimg.cn/large/007ghrgxgy1gls1okr52fj30s60hegmv.jpg" alt="线程池执行示意图"></p><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><ul><li><p>FixedThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>可重用固定线程数的线程池。FixedThreadPool的corePoolSize和maximumPoolSize都设置为nThreads，也就一位置FixedThreadPool只有核心线程，并且数量是固定的。</p></li><li><p>CachedThreadPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>根据需要创建线程的线程池。没有核心线程，非核心线程无界。空闲线程等待新任务事件为60s。</p></li><li><p>SingleThreadExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService<br>        (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用单个工作线程的线程池。有且仅有一个核心线程，能确保所有的任务在一个线程中按照顺序执行。</p></li><li><p>ScheduledThreadPool [ˈskedʒuːld]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure><p>能实现定时和周期性任务的线程池。</p></li></ul><h2 id="AsyncTask原理"><a href="#AsyncTask原理" class="headerlink" title="AsyncTask原理"></a>AsyncTask原理</h2><ul><li>onPreExecute：在主线程中执行。做准备工作。</li><li>doInbackground：在线程池中执行。onPreExecute执行之后执行，用于执行耗时操作。可以调用publishProgress更新进度。</li><li>onProgressUpdate：在主线程中执行。当调用publishProgress时，此方法会将进度更新到UI。</li><li>onPostExcute：在主线程中执行。当后台任务完成后，它会被执行。</li></ul><h4 id="Android3-0之前"><a href="#Android3-0之前" class="headerlink" title="Android3.0之前"></a>Android3.0之前</h4><p>核心线程数5个，最大线程数128个，KEEP_ALIVE为1s，采用LinkedBlockingQueue阻塞队列，大小为10。最多容纳138个任务（10+128），超出会进入饱和策略抛出异常。</p><h4 id="Android3-0之后"><a href="#Android3-0之后" class="headerlink" title="Android3.0之后"></a>Android3.0之后</h4><p>使用SerialExecutor串行线程池，保证一个时间段只有一个任务执行（不会并行处理 可以调用executeOnExecutor方法改为并行）。</p><p>定义了一个WorkerRunnable实现Callable接口，在call方法中调用doInbackground处理任务并得到结果，最终调用postResult方法传递结果。</p><p>定义一个FutureTask可管理的异步任务，它实现了Runnable和Callable接口，将WokerRunnable作为参数传入FutureTask。</p><p>当执行AsyncTask时，调用它的execute方法，该方法又调用executeOnExecutor方法，该方法首先调用onPreExecute方法，在给WorkerRunnable赋值，然后将FutureTask传入SerialExecutor。SerialExecutor线程池会调用FutureTask的run方法，最终会调用WorkerManger的call方法，call最终会调用postResult方法传递结果。</p><p>在postResult中创建Message对象保存结果，并获取Handler发消息，Handler会调用AsyncTask的finish方法。在finish中判断是否取消，调用onCancelled或者onPostExecute方法。</p>]]></content>
    
    
    <categories>
      
      <category>线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View体系与自定义View</title>
    <link href="/2020/12/14/View%E4%BD%93%E7%B3%BB%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <url>/2020/12/14/View%E4%BD%93%E7%B3%BB%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    
    <content type="html"><![CDATA[<h4 id="View与ViewGroup"><a href="#View与ViewGroup" class="headerlink" title="View与ViewGroup"></a>View与ViewGroup</h4><p>View是Android所有控件的基类，TextView、ImageView都是继承View。</p><p>ViewGroup顾名思义是View组、View的集合，继承于View，常见布局空间如：LinearLayout、RelativeLayout、FrameLayout都是继承自ViewGroup。</p><p>ViewGroup既可以包含View又可以包含ViewGroup</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>Android有两种坐标系：</p><ul><li>Android坐标系</li><li>View坐标系</li></ul><p>这两种坐标系能够帮助我们实现View的各种操作，例如：获取View位置。</p><h5 id="Android坐标系"><a href="#Android坐标系" class="headerlink" title="Android坐标系"></a>Android坐标系</h5><p>在Android中，将屏幕左上角的顶点作为Android坐标系的原点，这个原点向右是正X轴方向，向下是正Y轴方向。</p><p>在触控事件中，使用getRawX()和getRawY()方法获取。</p><p><img src="https://tvax3.sinaimg.cn/large/007ghrgxgy1glqxzjtdsgj30au0ehjr8.jpg" alt="Android坐标系"></p><h5 id="View坐标系"><a href="#View坐标系" class="headerlink" title="View坐标系"></a>View坐标系</h5><p>View到父控件的距离、点击事件位置等。（图中蓝色圆点为点击事件）</p><p><img src="https://tva4.sinaimg.cn/large/007ghrgxgy1glqxzsi40ej30ey0hct9q.jpg" alt="View坐标系"></p><h5 id="View获取自身的宽和高"><a href="#View获取自身的宽和高" class="headerlink" title="View获取自身的宽和高"></a>View获取自身的宽和高</h5><p>通过坐标系计算：</p><p>width=getRight()-getLeft()</p><p>height=getBottom()-getTop()</p><p>或者使用View的方法：</p><p>getHeight()、getWidth()</p><h5 id="View自身的坐标"><a href="#View自身的坐标" class="headerlink" title="View自身的坐标"></a>View自身的坐标</h5><p>通过如下方法可以获得View到其父控件（ViewGroup）的距离。</p><ul><li>getTop()          获取View自身顶边到其父布局顶边的距离</li><li>getLeft()          获取View自身左边到其父布局左边的距离</li><li>getRight()        获取View自身右边到其父布局左边的距离</li><li>getBottom()    获取View自身底边到其父布局顶边的距离</li></ul><h5 id="MotionEvent提供的方法"><a href="#MotionEvent提供的方法" class="headerlink" title="MotionEvent提供的方法"></a>MotionEvent提供的方法</h5><p>无论是View还是ViewGroup，点击事件都会由onTouchEvent(MotionEvent event)方法来处理。MotionEvent在用户交互中作用重大，其内部提供了很多事件常量，如：ACTION_DOWN、ACTION_UP和ACTION_MOVE。此外，MotionEvent也提供了获取焦点坐标的各种方法。</p><ul><li>getX()            获取点击事件距离控件左边的距离</li><li>getY()            获取点击事件距离控件顶边的距离</li><li>getRawX()    获取点击事件距离整个屏幕左边的距离</li><li>getRawY()    获取点击事件距离整个屏幕定边的距离</li></ul><h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>当点击事件传到View时，系统记下触摸点的坐标，手指移动时系统记下移动后触摸的坐标并计算出偏移量，并通过偏移量修改View的坐标。</p><p>实现View滑动有多种方法：layout()、offsetLeftAndRight()、offsetTopAndBottom()、LayoutParams、动画、scrollTo与scrollBy。</p><h4 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h4><p>自定义一个View重写onTouchEvent方法，计算移动的距离，使用View的layout方法重新放置他的位置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomView1</span> : <span class="hljs-type">View &#123;</span></span><br>    <span class="hljs-keyword">var</span> lastX: <span class="hljs-built_in">Float</span> = <span class="hljs-number">0f</span><br>    <span class="hljs-keyword">var</span> lastY: <span class="hljs-built_in">Float</span> = <span class="hljs-number">0f</span><br><br>    <span class="hljs-keyword">constructor</span>(context: Context) : <span class="hljs-keyword">super</span>(context)<br><br>    <span class="hljs-keyword">constructor</span>(context: Context, attributeSet: AttributeSet) : <span class="hljs-keyword">super</span>(context, attributeSet)<br><br>    <span class="hljs-keyword">constructor</span>(context: Context, attributeSet: AttributeSet, defStyleAttr: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(context, attributeSet, defStyleAttr)<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(event: <span class="hljs-type">MotionEvent</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">//获取手指触摸点的横纵坐标</span><br>        <span class="hljs-keyword">val</span> x = event.x<br>        <span class="hljs-keyword">val</span> y = event.y<br><br>        <span class="hljs-keyword">when</span> (event.action) &#123;<br>            MotionEvent.ACTION_DOWN -&gt; &#123;<br>                lastX = x<br>                lastY = y<br>            &#125;<br>            MotionEvent.ACTION_MOVE -&gt; &#123;<br>                <span class="hljs-comment">//计算移动的距离</span><br>                <span class="hljs-keyword">val</span> offsetX = x - lastX<br>                <span class="hljs-keyword">val</span> offsetY = y - lastY<br>                <span class="hljs-comment">//调用layout方法来重新放置它的位置</span><br>                layout(left + offsetX.toInt(), top + offsetY.toInt(), right + offsetX.toInt(), bottom + offsetY.toInt())<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-comment">//消耗事件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="offsetLeftAndRight、offsetTopAndBottom"><a href="#offsetLeftAndRight、offsetTopAndBottom" class="headerlink" title="offsetLeftAndRight、offsetTopAndBottom"></a>offsetLeftAndRight、offsetTopAndBottom</h4><p>将layout替换为上面两个方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">MotionEvent.ACTION_MOVE -&gt; &#123;<br>             <span class="hljs-comment">//计算移动的距离</span><br>             <span class="hljs-keyword">val</span> offsetX = x - lastX<br>             <span class="hljs-keyword">val</span> offsetY = y - lastY<br>             <span class="hljs-comment">//对left和right进行偏移</span><br>             offsetLeftAndRight(offsetX.toInt())<br>             <span class="hljs-comment">//对top和bottom进行偏移</span><br>             offsetTopAndBottom(offsetY.toInt())<br>         &#125;<br></code></pre></td></tr></table></figure><h4 id="LayoutParams-改变布局参数（ConstraintLayout不适用）"><a href="#LayoutParams-改变布局参数（ConstraintLayout不适用）" class="headerlink" title="LayoutParams 改变布局参数（ConstraintLayout不适用）"></a>LayoutParams 改变布局参数（ConstraintLayout不适用）</h4><p>LayoutParams保存了View的布局参数，因此我们可以通过LayoutParams来改变View的布局参数从而达到改变View位置的效果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">MotionEvent.ACTION_MOVE -&gt; &#123;<br>    <span class="hljs-comment">//计算移动的距离</span><br>    <span class="hljs-keyword">val</span> offsetX = x - lastX<br>    <span class="hljs-keyword">val</span> offsetY = y - lastY<br>    <span class="hljs-keyword">val</span> lp: ViewGroup.MarginLayoutParams = layoutParams <span class="hljs-keyword">as</span> ViewGroup.MarginLayoutParams<br>    lp.leftMargin = left + offsetX.toInt()<br>    lp.topMargin = top + offsetY.toInt()<br>    layoutParams = lp<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><h5 id="ViewPropertyAnimator-简洁、方便、高效"><a href="#ViewPropertyAnimator-简洁、方便、高效" class="headerlink" title="ViewPropertyAnimator 简洁、方便、高效"></a>ViewPropertyAnimator 简洁、方便、高效</h5><p>使用View#animate() 方法来获取一个 ViewPropertyAnimator 的对象实例</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">customView1.animate().alpha(<span class="hljs-number">0.5f</span>).rotation(<span class="hljs-number">360f</span>).scaleX(<span class="hljs-number">1.5f</span>).scaleY(<span class="hljs-number">1.5f</span>)<br>        .translationX(<span class="hljs-number">50f</span>).translationY(<span class="hljs-number">50f</span>).setDuration(<span class="hljs-number">5000</span>).start()<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/OCNYang/Android-Animation-Set">https://github.com/OCNYang/Android-Animation-Set</a>    Android 动画详尽教程</p></blockquote><h4 id="scrollTo和scrollBy"><a href="#scrollTo和scrollBy" class="headerlink" title="scrollTo和scrollBy"></a>scrollTo和scrollBy</h4><p>scrollTo(x,y)表示移动到一个具体的点，而scrollBy(x,y)表示移动的增量为dx、dy，scrollBy最终调用的是scrollTo。</p><p>它们移动的是View的内容，在ViewGroup中使用，则是移动其所有的子View</p><p>dx、dy需要传入负值</p><h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p>先了解Activity的构成有助于理解View的分发机制</p><h4 id="Activity的构成"><a href="#Activity的构成" class="headerlink" title="Activity的构成"></a>Activity的构成</h4><p>点击事件用MotionEvent来表示，当一个点击事件产生后，事件最先传递给Activity，而Activity包含一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平常所做应用所写的布局正是展现在ContentView中的。</p><p><img src="https://tva3.sinaimg.cn/large/007ghrgxgy1glqy0m6g7ej30dw0f6t8x.jpg" alt="Activity构成"></p><p>setContentView先拿到AppCompatDelegate代理对象，此对象是使任何Activity都可以得到AppCompat的支持，并且取代Activity类的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> <span class="hljs-keyword">int</span> layoutResID)</span> </span>&#123;<br>       getDelegate().setContentView(layoutResID);<br>   &#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> The &#123;<span class="hljs-doctag">@link</span> AppCompatDelegate&#125; being used by this Activity.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NonNull</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> AppCompatDelegate <span class="hljs-title">getDelegate</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (mDelegate == <span class="hljs-keyword">null</span>) &#123;<br>           mDelegate = AppCompatDelegate.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> mDelegate;<br>   &#125;<br></code></pre></td></tr></table></figure><p>setContentView在代理对象的实现类：AppCompatDelegateImpl中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resId)</span> </span>&#123;<br>       ensureSubDecor();<br>       ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);<br>       contentParent.removeAllViews();<br>       LayoutInflater.from(mContext).inflate(resId, contentParent);<br>       mAppCompatWindowCallback.getWrapped().onContentChanged();<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>在ensureSubDecor方法中有createSubDecor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureSubDecor</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (!mSubDecorInstalled) &#123;<br>           mSubDecor = createSubDecor();<br><br>           <span class="hljs-comment">// If a title was set before we installed the decor, propagate it now</span><br>       CharSequence title = getTitle();<br>           <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(title)) &#123;<br>               <span class="hljs-keyword">if</span> (mDecorContentParent != <span class="hljs-keyword">null</span>) &#123;<br>    ...<br></code></pre></td></tr></table></figure><p>进入createSubDecor方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ViewGroup <span class="hljs-title">createSubDecor</span><span class="hljs-params">()</span> </span>&#123;<br>    TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);<br><br>    <span class="hljs-keyword">if</span> (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123;<br>        a.recycle();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br>                <span class="hljs-string">&quot;You need to use a Theme.AppCompat theme (or descendant) with this activity.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, <span class="hljs-keyword">false</span>)) &#123;<br>        requestWindowFeature(Window.FEATURE_NO_TITLE);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, <span class="hljs-keyword">false</span>)) &#123;<br>        <span class="hljs-comment">// Don&#x27;t allow an action bar if there is no title.</span><br>        requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, <span class="hljs-keyword">false</span>)) &#123;<br>        requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, <span class="hljs-keyword">false</span>)) &#123;<br>        requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY);<br>    &#125;<br>    mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, <span class="hljs-keyword">false</span>);<br>    a.recycle();<br><br>    <span class="hljs-comment">// Now let&#x27;s make sure that the Window has installed its decor by retrieving it</span><br>    ensureWindow();<br>    mWindow.getDecorView();<br><br>    <span class="hljs-keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);<br>    ViewGroup subDecor = <span class="hljs-keyword">null</span>;<br><br><br>    <span class="hljs-keyword">if</span> (!mWindowNoTitle) &#123;<br>        <span class="hljs-keyword">if</span> (mIsFloating) &#123;<br>            <span class="hljs-comment">// If we&#x27;re floating, inflate the dialog title decor</span><br>            subDecor = (ViewGroup) inflater.inflate(<br>                    R.layout.abc_dialog_title_material, <span class="hljs-keyword">null</span>);<br><br>            <span class="hljs-comment">// Floating windows can never have an action bar, reset the flags</span><br>            mHasActionBar = mOverlayActionBar = <span class="hljs-keyword">false</span>;<br>    ...<br></code></pre></td></tr></table></figure><p> ensureWindow和mWindow.getDecorView方法确保了window的存在和顶层的装饰视图作为窗口添加到窗口管理器中即检索并添加DecorView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureWindow</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// We lazily fetch the Window for Activities, to allow DayNight to apply in</span><br>    <span class="hljs-comment">// attachBaseContext</span><br>    <span class="hljs-keyword">if</span> (mWindow == <span class="hljs-keyword">null</span> &amp;&amp; mHost <span class="hljs-keyword">instanceof</span> Activity) &#123;<br>        attachToWindow(((Activity) mHost).getWindow());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mWindow == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;We have not been given a Window&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Retrieve the top-level window decor view (containing the standard</span><br><span class="hljs-comment">   * window frame/decorations and the client&#x27;s content inside of that), which</span><br><span class="hljs-comment">   * can be added as a window to the window manager.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * &lt;p&gt;&lt;em&gt;Note that calling this function for the first time &quot;locks in&quot;</span><br><span class="hljs-comment">   * various window characteristics as described in</span><br><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@link</span> #setContentView(View, android.view.ViewGroup.LayoutParams)&#125;.&lt;/em&gt;&lt;/p&gt;</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Returns the top-level window decor view.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-function">View <span class="hljs-title">getDecorView</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>其中subDecor会根据条件加载各种布局，例如：subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple_overlay_action_mode, null);</p><p>R.layout.abc_screen_simple_overlay_action_mode布局文件为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;--This is an optimized layout for a screen, with the minimum set of features<br>enabled.--&gt;<br><br>&lt;androidx.appcompat.widget.FitWindowsFrameLayout<br>        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>        android:id=&quot;@+id/action_bar_root&quot;<br>        android:layout_width=&quot;match_parent&quot;<br>        android:layout_height=&quot;match_parent&quot;<br>        android:fitsSystemWindows=&quot;true&quot;&gt;<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/abc_screen_content_include&quot;</span> /&gt;</span><br><br>    &lt;androidx.appcompat.widget.ViewStubCompat<br>            android:id=&quot;@+id/action_mode_bar_stub&quot;<br>            android:inflatedId=&quot;@+id/action_mode_bar&quot;<br>            android:layout=&quot;@layout/abc_action_mode_bar&quot;<br>            android:layout_width=&quot;match_parent&quot;<br>            android:layout_height=&quot;wrap_content&quot; /&gt;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.appcompat.widget.FitWindowsFrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Now set the Window&#x27;s content view with the decor 现在用装饰设置窗口的内容视图</span><br>     mWindow.setContentView(subDecor);<br></code></pre></td></tr></table></figure><h4 id="View的事件分发机制-1"><a href="#View的事件分发机制-1" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h4><p>当我们点击屏幕时，就产生了点击事件，这个事件被封装成了一个类：MotionEvent。而当这个MotionEvent产生后，系统会将这个MotionEvent传递给View的层级，MotionEvent在View中的层级传递过程就是点击事件分发。</p><ul><li>dispatchTouchEvent(MotionEvent ev)            事件分发</li><li>onInterceptTouchEvent(MotionEvent ev)      事件拦截，在dispatchTouchEvent中调用，View没有提供该方法</li><li>onTouchEvent(MotionEvent ev)                       处理点击事件，在dispatchTouchEvent中调用</li></ul><p>当点击事件产生后，事件首先会传递给当前的Activity，这会调用Activity的dispatchTouchEvent方法，当然具体的事件处理工作都是交由Activity中的PhoneWindow来完成的，然后PhoneWindow再把事件处理工作交给DecorView，之后再由DecorView将事件处理工作交给根ViewGroup。</p><h5 id="ViewGroup-dispatchTouchEvent"><a href="#ViewGroup-dispatchTouchEvent" class="headerlink" title="ViewGroup#dispatchTouchEvent"></a>ViewGroup#dispatchTouchEvent</h5><p>根ViewGroup的dispatchTouchEvent方法会拦截DOWN事件，并初始化之前的状态（事件以DOWN开始，以UP结束）。然后判断当前ViewGroup是否拦截了事件（mFirstTouchTarget），如果没有拦截则交由子View处理，如果拦截且是DOWN事件则会执行onInterceptTouchEvent方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>      ...<br>          <span class="hljs-comment">// Check for interception.</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<br>          <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN<br>                  || mFirstTouchTarget != <span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>              <span class="hljs-keyword">if</span> (!disallowIntercept) &#123;<br>                  intercepted = onInterceptTouchEvent(ev);<br>                  ev.setAction(action); <span class="hljs-comment">// restore action in case it was changed</span><br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                  intercepted = <span class="hljs-keyword">false</span>;<br>              &#125;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// There are no touch targets and this action is not an initial down</span><br>              <span class="hljs-comment">// so this view group continues to intercept touches.</span><br>              intercepted = <span class="hljs-keyword">true</span>;<br>          &#125;<br>...<br></code></pre></td></tr></table></figure><p>onInterceptTouchEvent方法返回false不进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ev.isFromSource(InputDevice.SOURCE_MOUSE)<br>            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN<br>            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)<br>            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有拦截则进行子View的事件分发，ViewGroup会倒序遍历子View（最上层的子View开始），判断子元素是否能够接收到点击事件，如果能，则交于子View处理。如果不能则调用 super.dispatchTouchEvent(event); 也就是View的dispatchTouchEvent方法。</p><h5 id="接下来是View的分发，View-dispatchTouchEvent"><a href="#接下来是View的分发，View-dispatchTouchEvent" class="headerlink" title="接下来是View的分发，View#dispatchTouchEvent"></a>接下来是View的分发，View#dispatchTouchEvent</h5><p>如果OnTouchListener不为空并且onTouch方法返回true，则表示事件被消费，就不会执行onTouchEvent方法。所以OnTouchListener中的onTouch方法优先级高于onTouchEvent方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-keyword">null</span><br>               &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<br>               &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-keyword">this</span>, event)) &#123;<br>           result = <span class="hljs-keyword">true</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>           result = <span class="hljs-keyword">true</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>如果View的CLICKABLE或LONG_CLICKABLE为true（调用过setClickable和setLongClickable或者调用过setOnClickListenter和setLongClickListener），那么onTouchEvent方法就会返回true消耗事件。接着在ACTION_UP事件中调用performClick方法，如果View设置了点击事件，那么onClick方法就会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">performClick</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// We still need to call this method to handle the cases where performClick() was called</span><br>    <span class="hljs-comment">// externally, instead of through performClickInternal()</span><br>    notifyAutofillManagerOnClick();<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> result;<br>    <span class="hljs-keyword">final</span> ListenerInfo li = mListenerInfo;<br>    <span class="hljs-keyword">if</span> (li != <span class="hljs-keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="hljs-keyword">null</span>) &#123;<br>        playSoundEffect(SoundEffectConstants.CLICK);<br>        li.mOnClickListener.onClick(<span class="hljs-keyword">this</span>);<br>        result = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);<br><br>    notifyEnterOrExitForAutoFillIfNeeded(<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h5><p>onInterceptTouchEvent方法和onTouchEvent方法都在dispatchTouchEvent方法中调用。</p><p>点击事件由上而下传递规则：</p><p>当点击事件产生后会由Activity来处理，传递给PhoneWindow，再传递给DecorView，最后传递给顶层的ViewGroup。一般在事件传递中只考虑ViewGroup的onInterceptTouchEvent方法，因为一般情况下不会重写dispatchTouchEvent方法。对于根ViewGroup，点击事件首先传递给他的dispatchTouchEvent方法，如果他的onInterceptTouchEvent方法返回true则拦截该事件，这个事件就会交给他的onTouchEvent方法处理；如果返回false则这个事件交给他的子元素的dispatchTouchEvent处理，如此反复。到了最下面的View，就会调用View的dispatchTouchEvent方法处理，最终会调用View的onTouchEvent方法。</p><p>点击事件由下而上的传递：</p><p>当点击事件传给底层View时，如果其onTouchEvent方法返回true，则事件由底层的View消耗并处理；返回false表示该View不做处理传递给父View的onTouchEvent方法处理，如果父View的onTouchEvent方法依旧返回false，则继续向上传递。</p><h2 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h2><p>View的工作流程指的就是measure、layout和draw。其中measure用来测量View的宽高，layout确定View的位置，draw用来绘制View。</p><h5 id="Activity的创建过程"><a href="#Activity的创建过程" class="headerlink" title="Activity的创建过程"></a>Activity的创建过程</h5><p>Activity的startActivity方法最终是调用ActivityThead的handleLaunchActivity方法来创建Activity，在handleLaunchActivity方法中，有performLaunchActivity方法创建Activity，它会调用Activity的onCreate方法，从而完成DecorView的创建。</p><p>接着会调用handleResumeActivity方法，该方法会调用Activity的onResume方法。在该方法中会将Activity的DecorView放入WindowManager中，即WindowManagerImpl的addView方法，而WindowManagerImpl的addView调用的是WindowManagerGlobal的addView方法，在WindowManagerGlobal的addView方法中会创建一个ViewRootImpl实例，然后调用ViewRootImpl的setView方法将DecorView作为参数传入，这样就把DecorView加载到了Window中。但还没完，View还需要进行measure、layout以及draw。</p><h5 id="ViewRootImpl的performTraversals【pərˈfoːrm-trəˈvərs-ə-ls】方法"><a href="#ViewRootImpl的performTraversals【pərˈfoːrm-trəˈvərs-ə-ls】方法" class="headerlink" title="ViewRootImpl的performTraversals【pərˈfɔːrm|trəˈvərs(ə)ls】方法"></a>ViewRootImpl的performTraversals【pərˈfɔːrm|trəˈvərs(ə)ls】方法</h5><p>ViewRootImpl有一个performTraversals方法，此方法使得ViewTree开始View的工作流程。</p><p>performTraversals方法主要执行3个方法：performMeasure、performLayout和performDraw，在其方法内部又会分别调用View的measure、layout和draw方法。</p><h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><p>MeasureSpec是View的内部类，其封装了一个View的规格尺寸，包括View的宽和高的信息，它的作用是在Measure流程中，系统会将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec，然后再onMeasure方法中根据这个MeasureSpec来确定View的宽和高。</p><p>MeasureSpec代表了32位的int值，其中高2位代表了SpecMode（测量模式），低30位则代表SpecSize（测量大小）。</p><h5 id="3种测量模式"><a href="#3种测量模式" class="headerlink" title="3种测量模式"></a>3种测量模式</h5><ul><li> UNSPECIFIED[ʌnˈs pesɪfaɪd]：未指定模式，View想多大就多大，父容器不做限制，一般用于系统内部测量。</li><li> AT_MOST：最大模式，对应于wrap_content属性，子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值。</li><li> EXACTLY：精确模式，对应于match_parent属性和具体的数值，父容器测量出View所需要的大小，也就是SpecSize的值。</li></ul><p>对于每一个View，都持有一个MeasureSpec，而该MeasureSpec则保存了该View的尺寸规格。在View的测量流程中，通过makeMeasureSpec来保存宽和高的信息，通过getMode或getSize得到模式的宽和高。MeasureSpec是受自身LayoutParams和父容器的MeasureSpec共同影响的。</p><p>但是，DecorView没有父容器，所以对于DecorView来说，他的MeasureSpec由自身的LayoutParams和窗口的尺寸界定，这一点和普通View是不一样的。</p><h4 id="View的measure流程"><a href="#View的measure流程" class="headerlink" title="View的measure流程"></a>View的measure流程</h4><p>measure用来测量View的宽和高，他的流程分为View的measure流程和ViewGroup的measure流程，直播过ViewGroup的measure流程除了要完成自己的测量，还要遍历地调用子元素的measure方法。</p><h5 id="View的measure流程-1"><a href="#View的measure流程-1" class="headerlink" title="View的measure流程"></a>View的measure流程</h5><p>首先是View的onMeasure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),<br>            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));<br>&#125;<br></code></pre></td></tr></table></figure><p>setMeasuredDimension是用来设置View的宽高的，重点在getDefaultSize方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> measureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = size;<br>    <span class="hljs-keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>    <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>        result = size;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>    <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>        result = specSize;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>specMode是View的测量模式，specSize是View的测量大小。这里根据不同的specMode来返回不同的result，在AT_MOST和EXACTLY模式下都返回SpecSize，即View在这两种模式下的测量宽高直接取决于SpecSize。也就是说，对于一个继承自View的自定义View来说，它的warp_content和match_parent属性效果是一样的。因此如果要实现自定义View的wrap_content，则要重写onMeasure方法，并对自定义View的wrap_content属性进行处理。UNSPECIFIED模式返回的是size，这个值来自于getSuggestedMinimumWidth和getSuggestedMinimumHeight方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuggestedMinimumWidth</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果View没有设置背景，则返回mMinWidth（如果没有调用setMinimumWidth就是0）；如果设置了背景，就返回MMinWidth和Drawable的最小宽度之间的最大值。</p><h5 id="ViewGroup的measure流程"><a href="#ViewGroup的measure流程" class="headerlink" title="ViewGroup的measure流程"></a>ViewGroup的measure流程</h5><p>对于ViewGroup，它不只要测量自身，还要遍历地调用子元素的measure方法。ViewGroup中没有定义onMeasure方法但是有measureChildren方法，遍历调用子View的measureChild方法，measureChild会获取子View的LayoutParams属性和MeasureSpec（子View的MeasureSpec是根据父容器的MeasureSpec结合子View的LayoutParams得出的），并调用子View的measure方法测量。</p><h4 id="View的layout流程"><a href="#View的layout流程" class="headerlink" title="View的layout流程"></a>View的layout流程</h4><p>layout方法的作用是确定元素的位置。ViewGroup中的layout方法用来确定子元素的位置，View中的layout方法用来确定自身的位置。</p><p>layout方法的4个参数l、t、r、b分别是View从左、上、右、下相对于其父容器的距离，setFrame方法用传进来的l、t、r、b这4个参数分别初始化mLeft、mTop、mRight、mBottom，这样就确定了View在父容器中的位置。在调用setFrame方法后，会调用onLayout方法用于自定义。</p><h4 id="View的draw流程（View-draw-讲的很详细）"><a href="#View的draw流程（View-draw-讲的很详细）" class="headerlink" title="View的draw流程（View#draw 讲的很详细）"></a>View的draw流程（View#draw 讲的很详细）</h4><ol><li>如果需要，则绘制背景                                                                                        drawBackground方法</li><li>保存当前canvas层                </li><li>绘制View内容                                                                                                       onDraw方法</li><li>绘制子View                                                                                                           dispatchDraw方法</li><li>如果需要，则绘制View的褪色边缘，这类似于阴影效果</li><li>绘制装饰，如滚动条                                                                                            onDrawForeground方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Android View</tag>
      
      <tag>Custom View</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android5.0之 Notification</title>
    <link href="/2020/12/07/Android5.0%E4%B9%8B%20Notification/"/>
    <url>/2020/12/07/Android5.0%E4%B9%8B%20Notification/</url>
    
    <content type="html"><![CDATA[<p>Notification 可以让我们在获得消息的时候，在状态栏、锁屏界面来显示相应的信息。</p><ul><li>普通Notification</li><li>悬挂式Notification</li></ul><h4 id="普通Notification"><a href="#普通Notification" class="headerlink" title="普通Notification"></a>普通Notification</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//获取NotificationManager来进行管理Notification</span><br>      NotificationManager notificationManager = (android.app.NotificationManager) getSystemService(NOTIFICATION_SERVICE);<br>      <span class="hljs-comment">//创建通知Builder对象</span><br>      NotificationCompat.Builder builder = <span class="hljs-keyword">new</span> NotificationCompat.Builder(MainActivity.<span class="hljs-keyword">this</span>);<br>      <span class="hljs-comment">//判断是否是8.0以上</span><br>      <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>          NotificationChannel notificationChannel = <span class="hljs-keyword">new</span> NotificationChannel(<span class="hljs-string">&quot;NC&quot;</span>, <span class="hljs-string">&quot;通知&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT);<br>          <span class="hljs-comment">//如果没有channel就创建</span><br>          <span class="hljs-keyword">if</span> (notificationManager.getNotificationChannel(<span class="hljs-string">&quot;NC&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br>              notificationManager.createNotificationChannel(notificationChannel);<br>          &#125;<br>          builder.setChannelId(<span class="hljs-string">&quot;NC&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// 使用PendingIntent控制跳转</span><br>      Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(<span class="hljs-string">&quot;https://baidu.com&quot;</span>));<br>      PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, intent, <span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//设置通知属性</span><br>      builder.setContentIntent(pendingIntent);<br>      builder.setSmallIcon(R.drawable.icon);<br>      builder.setAutoCancel(<span class="hljs-keyword">true</span>);<br>      builder.setContentTitle(<span class="hljs-string">&quot;普通通知&quot;</span>);<br>      builder.setContentText(<span class="hljs-string">&quot;我是通知内容&quot;</span>);<br>      notification = builder.build();<br>notificationManager.notify(<span class="hljs-number">1</span>, notification);<br><span class="hljs-comment">//NotificationManagerCompat.from(getApplicationContext()).notify(0,notification);</span><br></code></pre></td></tr></table></figure><h4 id="悬挂式Notification"><a href="#悬挂式Notification" class="headerlink" title="悬挂式Notification"></a>悬挂式Notification</h4><p>悬挂式Notification不需要下拉通知栏，直接悬挂在屏幕上方，焦点不变，让在用户操作的界面，不会打断用户的操作，会自动消失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//设置悬挂</span><br>      Intent hangIntent = <span class="hljs-keyword">new</span> Intent();<br>      hangIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>      hangIntent.setClass(<span class="hljs-keyword">this</span>, MainActivity.class);<br>      PendingIntent hangPendingIntent = PendingIntent.getActivity(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, hangIntent, PendingIntent.FLAG_CANCEL_CURRENT);<br><span class="hljs-comment">//builder 加上这个属性</span><br>builder.setFullScreenIntent(hangPendingIntent, <span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><hr><h5 id="通知的各种属性："><a href="#通知的各种属性：" class="headerlink" title="通知的各种属性："></a>通知的各种属性：</h5><ul><li>设置标题 setContentTitle(CharSequence)</li><li>设置文字内容 setContentText(CharSequence)</li><li>设置副文字 setSubContextText(CharSequence)</li><li>设置大图标 setLargeIcon(Bitmap) 不设置时默认为应用图标</li><li>设置小图标 setSmallIcon(int) 参数为图片资源Id</li><li>设置颜色 setColor(int color) 参数为RGB值</li><li>设置声音 setSound</li><li>设置震动 setVibrate</li><li>设置闪灯 setLight(int,int,int) 第一个int为颜色的资源id,第二个和第三个是闪灯开启和关闭的时间,单位为毫秒</li><li>设置点击后是否自动取消 setAutoCancel(boolean)</li></ul><h5 id="进度条："><a href="#进度条：" class="headerlink" title="进度条："></a>进度条：</h5><p>从4.1开始通知里自带进度条.通过<code>setProgress(in max,int progress,boolean indeterminate)</code>来设置进度</p><ul><li>max 进度最大值</li><li>progress 当前进度</li><li>indeterminate 是否是无限循环 true表示无限循环进度条,不需要进度及最大值.false反之</li></ul><p>当进度条加载完毕后可以能过<code>setProgress(0,0,false)</code>来隐藏进度条.</p><h5 id="ID："><a href="#ID：" class="headerlink" title="ID："></a>ID：</h5><p>id需要自己设置，一个Id对应一个通知。</p><p>NotificationService 收到Notification后会根据Id去查找对应的View。</p><p>如果不存在则创建一个，如果存在则更新UI。<br>也就是说如果id相同时，后续的通知会把之前的通知替换掉，如果id不同时会弹出多个通知。</p><h5 id="Style："><a href="#Style：" class="headerlink" title="Style："></a>Style：</h5><ul><li><p>MediaStyle 媒体播放器样式，可以最多提供5个Action，用与后台播放媒体文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">builer.setStyle(<span class="hljs-keyword">new</span> NotificationCompat.MediaStyle()<br>                .setMediaSession(MediaSession.Token));<br></code></pre></td></tr></table></figure></li><li><p>BigPictureStyle 大图样式，可以附加一张图片，扩展显示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buider.setStyle(<span class="hljs-keyword">new</span> NotificationCompat.BigPictureStyle()<br>                .bigPicture(Bitmap));<br></code></pre></td></tr></table></figure></li><li><p>InboxStyle 文字式表样式，可以以列表的形式显示最多5行的文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">builer.setStyle(<span class="hljs-keyword">new</span> NotificationCompat.InboxStyle()<br>                .setLine(CharSequence)<br>                .setLine(CharSequence));<br></code></pre></td></tr></table></figure></li><li><p>BigTextStyle 多文字内容，下拉显示全部文字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buider.setStyle(<span class="hljs-keyword">new</span> NotificationCompat.BigTextStyle()<br>                .bitText(CharSequence));<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>Android通知及RemoteViews整理</p><p><a href="https://jestar719.github.io/2017/02/27/Android%E9%80%9A%E7%9F%A5%E5%8F%8ARemoteView%E6%95%B4%E7%90%86/">https://jestar719.github.io/2017/02/27/Android%E9%80%9A%E7%9F%A5%E5%8F%8ARemoteView%E6%95%B4%E7%90%86/</a> </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android 5.0</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android Notification</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 5.0之 RecyclerView</title>
    <link href="/2020/12/04/Android5.0%E4%B9%8B%20RecyclerView/"/>
    <url>/2020/12/04/Android5.0%E4%B9%8B%20RecyclerView/</url>
    
    <content type="html"><![CDATA[<p>本文有：</p><ol><li>RecycleView 的基础使用</li><li>RecycleView 的相关框架</li><li>RecycleView 的DiffUtil</li><li>RecycleView 和ListView、GridView的区别</li></ol><h2 id="1-RecycleView-的基础使用"><a href="#1-RecycleView-的基础使用" class="headerlink" title="1.RecycleView 的基础使用"></a>1.RecycleView 的基础使用</h2><p>添加依赖：（以AndroidX为例）</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span><br></code></pre></td></tr></table></figure><p>在Activity布局中引入RecycleView：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;androidx.recyclerview.widget.RecyclerView<br>        android:id=&quot;@+id/main_recyclerView&quot;<br>        android:layout_width=&quot;0dp&quot;<br>        android:layout_height=&quot;0dp&quot;<br>        android:layout_marginBottom=&quot;200dp&quot;<br>        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;<br>        app:layout_constraintEnd_toEndOf=&quot;parent&quot;<br>        app:layout_constraintStart_toStartOf=&quot;parent&quot;<br>        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;<br></code></pre></td></tr></table></figure><p>Activity中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">RecyclerView main_recyclerView = findViewById(R.id.main_recyclerView);<br>    <span class="hljs-comment">//设置布局管理器</span><br>    main_recyclerView.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">//设置item增加和删除时的动画</span><br>    main_recyclerView.setItemAnimator(<span class="hljs-keyword">new</span> DefaultItemAnimator());<br>    <span class="hljs-comment">//设置适配器</span><br>    mainAdapter = <span class="hljs-keyword">new</span> MainAdapter();<br>    main_recyclerView.setAdapter(mainAdapter);<br></code></pre></td></tr></table></figure><p>RecyclerView 适配器(上面的 MainAdapter )即适配每个item数据，将数据可视化展现。</p><p>MainAdapter 需要继承RecyclerView.Adapter，而RecyclerView.Adapter需要一个RecyclerView.ViewHolder，RecyclerView.ViewHolder 可以写在Adapter里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">MainAdapter</span>.<span class="hljs-title">MainViewHolder</span>&gt;</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span></span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RecyclerView.Adapter 需要实现的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建ViewHolder，填充布局 R.layout.item_main </span><br><span class="hljs-comment">//R.layout.item_main 每个数据的具体载体</span><br>   <span class="hljs-meta">@NonNull</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> MainViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MainViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_main, parent, <span class="hljs-keyword">false</span>));<br>   &#125;<br><br>   <span class="hljs-comment">//绑定数据</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MainViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>       holder.main_textView.setText(mData.get(position));<br>   &#125;<br><br>   <span class="hljs-comment">//设置item数量</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> mData.size();<br>   &#125;<br></code></pre></td></tr></table></figure><p>MainViewHolder 保存view (holder.main_textView)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TextView main_textView;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View itemView)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>(itemView);<br>            main_textView = itemView.findViewById(R.id.main_textView);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="关于分割线"><a href="#关于分割线" class="headerlink" title="关于分割线"></a>关于分割线</h4><p>分割线许自己定义类继承RecyclerView.ItemDecoration类。该类需要一个Drawable对象绘制分割线（mDivider）、一个变量保存横向或纵向属性（mOrientation）。</p><p>核心在于重写 onDraw方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绘制分割线</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas c, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onDraw(c, parent, state);<br>       <span class="hljs-keyword">if</span> (mOrientation == LinearLayoutManager.VERTICAL) &#123;<br>           drawVertical(c, parent);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           drawHorizontal(c, parent);<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">//绘制纵向 item 分割线</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawVertical</span><span class="hljs-params">(Canvas canvas, RecyclerView parent)</span> </span>&#123;<br>       <span class="hljs-comment">//分割线的top对齐RecyclerView的top+内边距</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = parent.getPaddingTop();<br>       <span class="hljs-comment">//分割线的底为 整个RecyclerView的高度-底部内边距</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = parent.getMeasuredHeight() - parent.getPaddingBottom();<br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childSize = parent.getChildCount();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childSize; i++) &#123;<br>           <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);<br>           RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams();<br>           <span class="hljs-comment">//纵向分割线在item右方</span><br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = child.getRight() + layoutParams.rightMargin;<br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = left + mDividerHeight;<br>           <span class="hljs-keyword">if</span> (mDivider != <span class="hljs-keyword">null</span>) &#123;<br>               mDivider.setBounds(left, top, right, bottom);<br>               mDivider.draw(canvas);<br>           &#125;<br>           <span class="hljs-keyword">if</span> (mPaint != <span class="hljs-keyword">null</span>) &#123;<br>               canvas.drawRect(left, top, right, bottom, mPaint);<br>           &#125;<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">//绘制横向 item 分割线</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHorizontal</span><span class="hljs-params">(Canvas canvas, RecyclerView parent)</span> </span>&#123;<br>       <span class="hljs-comment">//分割线的起始为RecyclerView的左+左内边距</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = parent.getPaddingLeft();<br>       <span class="hljs-comment">//右边为测量宽度-右内边距</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = parent.getMeasuredWidth() - parent.getPaddingRight();<br>       <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childSize = parent.getChildCount();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; childSize; i++) &#123;<br>           <span class="hljs-keyword">final</span> View child = parent.getChildAt(i);<br>           RecyclerView.LayoutParams layoutParams = (RecyclerView.LayoutParams) child.getLayoutParams();<br>           <span class="hljs-comment">//分割线在每个item下方 还需要考虑外边距</span><br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> top = child.getBottom() + layoutParams.bottomMargin;<br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bottom = top + mDividerHeight;<br><br>           <span class="hljs-keyword">if</span> (mDivider != <span class="hljs-keyword">null</span>) &#123;<br>               mDivider.setBounds(left, top, right, bottom);<br>               mDivider.draw(canvas);<br>           &#125;<br>           <span class="hljs-keyword">if</span> (mPaint != <span class="hljs-keyword">null</span>) &#123;<br>               canvas.drawRect(left, top, right, bottom, mPaint);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="2-RecycleView的相关框架"><a href="#2-RecycleView的相关框架" class="headerlink" title="2.RecycleView的相关框架"></a>2.RecycleView的相关框架</h2><h3 id="BRVAH：强大而灵活的RecyclerView-Adapter"><a href="#BRVAH：强大而灵活的RecyclerView-Adapter" class="headerlink" title="BRVAH：强大而灵活的RecyclerView Adapter"></a>BRVAH：强大而灵活的RecyclerView Adapter</h3><p>github地址：</p><p><a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper">https://github.com/CymChad/BaseRecyclerViewAdapterHelper</a></p><h2 id="3-DiffUtil"><a href="#3-DiffUtil" class="headerlink" title="3.DiffUtil"></a>3.DiffUtil</h2><p>更高效，更顺畅的更新RecycleView数据。</p><p>直接使用 notifyDataSetChanged 更新数据的缺陷：</p><ul><li>没有更新动画</li><li>刷新整个RecycleView，效率低</li></ul><p>DiffUtil 自动计算新老数据集的差异，并根据差异情况，自动调用以下四个方法</p><ul><li>notifyItemRangeInserte</li><li>notifyItemRangeRemoved</li><li>notifyItemMoved</li><li>notifyItemRangeChanged</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>写一个类实现 DiffUtil.Callback ，添加2个成员变量保存新老数据，重写5个方法：getOldListSize()、getNewListSize()、areItemsTheSame()、areContentsTheSame()、getChangePayload();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiffUtilImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DiffUtil</span>.<span class="hljs-title">Callback</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Person&gt; oldPersonList, newPersonList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiffUtilImpl</span><span class="hljs-params">(List&lt;Person&gt; oldPersonList, List&lt;Person&gt; newPersonList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.oldPersonList = oldPersonList;<br>        <span class="hljs-keyword">this</span>.newPersonList = newPersonList;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOldListSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> oldPersonList == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : oldPersonList.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNewListSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> newPersonList == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : newPersonList.size();<br>    &#125;<br><br>    <span class="hljs-comment">//判断两个对象是否是相同的Item。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areItemsTheSame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldItemPosition, <span class="hljs-keyword">int</span> newItemPosition)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> oldPersonList.get(oldItemPosition).id == newPersonList.get(newItemPosition).id;<br>    &#125;<br><br>    <span class="hljs-comment">//检查两个item是否含有相同的数据</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">areContentsTheSame</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldItemPosition, <span class="hljs-keyword">int</span> newItemPosition)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> oldPersonList.get(oldItemPosition).equals(newPersonList.get(newItemPosition));<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getChangePayload</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldItemPosition, <span class="hljs-keyword">int</span> newItemPosition)</span> </span>&#123;<br>        Person OLD = oldPersonList.get(oldItemPosition);<br>        Person NEW = newPersonList.get(newItemPosition);<br>        Bundle payload = <span class="hljs-keyword">new</span> Bundle();<br>        <span class="hljs-keyword">if</span> (!OLD.name.equals(NEW.name)) &#123;<br>            payload.putString(<span class="hljs-string">&quot;name&quot;</span>, NEW.name);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (OLD.age != NEW.age) &#123;<br>            payload.putInt(<span class="hljs-string">&quot;age&quot;</span>, NEW.age);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (payload.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> payload;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getChangePayload 方法可以配合 Adapter中的 onBindViewHolder 方法实现局部更新：（<strong>payloads对象不会为null，但是它可能是空（empty）</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> DiffUtilViewHolder holder, <span class="hljs-keyword">int</span> position, <span class="hljs-meta">@NonNull</span> List&lt;Object&gt; payloads)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (payloads.isEmpty()) &#123;<br>           onBindViewHolder(holder, position);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           Bundle payload = (Bundle) payloads.get(<span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">for</span> (String key : payload.keySet()) &#123;<br>               <span class="hljs-keyword">switch</span> (key) &#123;<br>                   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;name&quot;</span>:<br>                       holder.name_textView.setText(payload.getString(key));<br>                       <span class="hljs-keyword">break</span>;<br>                   <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;age&quot;</span>:<br>                       holder.age_textView.setText(String.valueOf(payload.getInt(key)));<br>                       <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>计算、更新数据，通知Adapter更新数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(<span class="hljs-keyword">new</span> DiffUtilImpl(personList, list), <span class="hljs-keyword">true</span>);<br><br>personList.clear();<br>personList.addAll(list);<br><br>diffResult.dispatchUpdatesTo(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>dispatchUpdatesTo 方法会创建一个 AdapterListUpdateCallback 类，该类保存传入的Adapter 对象，且该类实现 ListUpdateCallback 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/** 源码</span><br><span class="hljs-comment"> * ListUpdateCallback that dispatches update events to the given adapter.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> DiffUtil.DiffResult#dispatchUpdatesTo(RecyclerView.Adapter)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterListUpdateCallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ListUpdateCallback</span> </span>&#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RecyclerView.Adapter mAdapter;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates an AdapterListUpdateCallback that will dispatch update events to the given adapter.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> adapter The Adapter to send updates to.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdapterListUpdateCallback</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> RecyclerView.Adapter adapter)</span> </span>&#123;<br>        mAdapter = adapter;<br>    &#125;<br><br>    <span class="hljs-comment">/** &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInserted</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        mAdapter.notifyItemRangeInserted(position, count);<br>    &#125;<br><br>    <span class="hljs-comment">/** &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRemoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        mAdapter.notifyItemRangeRemoved(position, count);<br>    &#125;<br><br>    <span class="hljs-comment">/** &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromPosition, <span class="hljs-keyword">int</span> toPosition)</span> </span>&#123;<br>        mAdapter.notifyItemMoved(fromPosition, toPosition);<br>    &#125;<br><br>    <span class="hljs-comment">/** &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> count, Object payload)</span> </span>&#123;<br>        mAdapter.notifyItemRangeChanged(position, count, payload);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>dispatchUpdatesTo 方法还会将这个CallBack封装为 BatchingListUpdateCallback（同样实现了 ListUpdateCallback 接口） 最后调用 batchingCallback.dispatchLastEvent() 触发Adapter的更新。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * BatchingListUpdateCallback holds onto the last event to see if it can be merged with the</span><br><span class="hljs-comment">    * next one. When stream of events finish, you should call this method to dispatch the last</span><br><span class="hljs-comment">    * event.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLastEvent</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (mLastEventType == TYPE_NONE) &#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-keyword">switch</span> (mLastEventType) &#123;<br>           <span class="hljs-keyword">case</span> TYPE_ADD:<br>               mWrapped.onInserted(mLastEventPosition, mLastEventCount);<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> TYPE_REMOVE:<br>               mWrapped.onRemoved(mLastEventPosition, mLastEventCount);<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> TYPE_CHANGE:<br>               mWrapped.onChanged(mLastEventPosition, mLastEventCount, mLastEventPayload);<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       mLastEventPayload = <span class="hljs-keyword">null</span>;<br>       mLastEventType = TYPE_NONE;<br>   &#125;<br><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMoved</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fromPosition, <span class="hljs-keyword">int</span> toPosition)</span> </span>&#123;<br>       dispatchLastEvent(); <span class="hljs-comment">// moves are not merged</span><br>       mWrapped.onMoved(fromPosition, toPosition);<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>张旭童 RecyclerView的好伴侣：详解DiffUtil</p><p><a href="https://blog.csdn.net/zxt0601/article/details/52562770">https://blog.csdn.net/zxt0601/article/details/52562770</a> </p></blockquote><h2 id="4-RecycleView-和ListView、GridView的区别"><a href="#4-RecycleView-和ListView、GridView的区别" class="headerlink" title="4.RecycleView 和ListView、GridView的区别"></a>4.RecycleView 和ListView、GridView的区别</h2><ul><li>低耦合性：ListView，GridView只能实现单一的布局方式，RecyclerView可通过setLayoutManager实现ListView的垂直布局，GridView的水平布局，以及瀑布流布局，实现了控件和布局方式的解耦。</li><li>高效：ListView，GridView在创建ItemView时，为了提高执行效率官方推荐使用视图缓存ViewHolder，RecyclerView直接将ViewHolder相关方法封好了。ListView，GridView增删子项调用notifyDataSetChanged后，会将所有ItemView重新生成一遍。<br>RecyclerView多了notifyItemInserted,notifyItemRemoved,notifyItemMoved,notifyItemChanged等可以更新单项ItemView的方法，效率大大提高。</li><li>丰富动画效果：ListView，GridView想实现ItemView的拖拽排序等操作非常复杂，所有的代码均需由程序员实现，还要考虑与原有控件，界面手势处理兼容性，实现难度大，执行效率不高。RecyclerView的扩展包提了ItemTouchHelper类，可以轻松的实现ItemView之间的拖拽排序等动画效果。</li></ul><h4 id="关于RecycleView的缓存与回收机制"><a href="#关于RecycleView的缓存与回收机制" class="headerlink" title="关于RecycleView的缓存与回收机制"></a>关于RecycleView的缓存与回收机制</h4><p>首先是ListView的缓存：</p><ul><li>Active View ：是缓存在屏幕内的ItemView，当列表数据发生变化时，屏幕内的数据可以直接拿来复用，无须进行数据绑定。</li><li>Scrap view：缓存屏幕外的ItemView，这里所有的缓存的数据都是”脏的”，也就是数据需要重新绑定，也就是说屏幕外的所有数据在进入屏幕的时候都要走一遍getView（）方法。</li></ul><p>RecycleView的4级缓存：</p><ul><li><strong>Scrap</strong>：对应ListView 的Active View，就是屏幕内的缓存数据。</li><li><strong>Cache</strong>：刚刚移出屏幕的缓存数据，默认大小是2个，当其容量被充满同时又有新的数据添加的时候，会根据FIFO原则，把优先进入的缓存数据移出并放到下一级缓存中，然后再把新的数据添加进来。</li><li><strong>ViewCacheExtension</strong>：google留给开发者自己来自定义缓存。</li><li><strong>RecycledViewPool</strong>：默认的缓存数量是5个，RecycledViewPool缓存的ViewHolder是全新的，取出来的时候需要走onBindViewHolder 方法。</li></ul><blockquote><p>肖邦kaka 让你彻底掌握RecyclerView的缓存机制</p><p><a href="https://www.jianshu.com/p/3e9aa4bdaefd">https://www.jianshu.com/p/3e9aa4bdaefd</a> </p></blockquote><h2 id="RecyclerView滚动到指定位置并置顶"><a href="#RecyclerView滚动到指定位置并置顶" class="headerlink" title="RecyclerView滚动到指定位置并置顶"></a>RecyclerView滚动到指定位置并置顶</h2><p>点进 RecyclerView#smoothScrollToPosition(int position) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Starts a smooth scroll to an adapter position.</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * To support smooth scrolling, you must override</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> LayoutManager#smoothScrollToPosition(RecyclerView, State, int)&#125; and create a</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> SmoothScroller&#125;.</span><br><span class="hljs-comment">    * &lt;p&gt;</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> LayoutManager&#125; is responsible for creating the actual scroll action. If you want to</span><br><span class="hljs-comment">    * provide a custom smooth scroll logic, override</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> LayoutManager#smoothScrollToPosition(RecyclerView, State, int)&#125; in your</span><br><span class="hljs-comment">    * LayoutManager.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> position The adapter position to scroll to</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@see</span> LayoutManager#smoothScrollToPosition(RecyclerView, State, int)</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">smoothScrollToPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (mLayoutSuppressed) &#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (mLayout == <span class="hljs-keyword">null</span>) &#123;<br>           Log.e(TAG, <span class="hljs-string">&quot;Cannot smooth scroll without a LayoutManager set. &quot;</span><br>                   + <span class="hljs-string">&quot;Call setLayoutManager with a non-null argument.&quot;</span>);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       mLayout.smoothScrollToPosition(<span class="hljs-keyword">this</span>, mState, position);<br>   &#125;<br></code></pre></td></tr></table></figure><p>LayoutManager负责创建实际的滚动操作，并且提到了创建一个SmoothScroller，看看LinearLayoutManager中的此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">smoothScrollToPosition</span><span class="hljs-params">(RecyclerView recyclerView, RecyclerView.State state,</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>       LinearSmoothScroller linearSmoothScroller =<br>               <span class="hljs-keyword">new</span> LinearSmoothScroller(recyclerView.getContext());<br>       linearSmoothScroller.setTargetPosition(position);<br>       startSmoothScroll(linearSmoothScroller);<br>   &#125;<br></code></pre></td></tr></table></figure><p>LinearLayoutManager创建了一个LinearSmoothScroller，而这个LinearSmoothScroller就是需要自定义的SmoothScroller。点进这个LinearSmoothScroller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinearSmoothScroller</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">SmoothScroller</span> </span>&#123;<br>...<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Align child view&#x27;s left or top with parent view&#x27;s left or top</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDtToFit(int, int, int, int, int)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDxToMakeVisible(android.view.View, int)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDyToMakeVisible(android.view.View, int)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SNAP_TO_START = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Align child view&#x27;s right or bottom with parent view&#x27;s right or bottom</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDtToFit(int, int, int, int, int)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDxToMakeVisible(android.view.View, int)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDyToMakeVisible(android.view.View, int)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SNAP_TO_END = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;Decides if the child should be snapped from start or end, depending on where it</span><br><span class="hljs-comment">     * currently is in relation to its parent.&lt;/p&gt;</span><br><span class="hljs-comment">     * &lt;p&gt;For instance, if the view is virtually on the left of RecyclerView, using</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> SNAP_TO_ANY&#125; is the same as using &#123;<span class="hljs-doctag">@code</span> SNAP_TO_START&#125;&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDtToFit(int, int, int, int, int)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDxToMakeVisible(android.view.View, int)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #calculateDyToMakeVisible(android.view.View, int)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SNAP_TO_ANY = <span class="hljs-number">0</span>;<br>    ...<br></code></pre></td></tr></table></figure><p>主要是三个常量设置了滚动方式：</p><ul><li>将子视图的左或上与父视图的左或上对齐。 SNAP_TO_START</li><li>将子视图的右或底部与父视图的右或底部对齐。 SNAP_TO_END</li></ul><p>帮助LayoutManager计算显示垂直或水平滚动距离：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Helper method for &#123;<span class="hljs-doctag">@link</span> #calculateDxToMakeVisible(android.view.View, int)&#125; and</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> #calculateDyToMakeVisible(android.view.View, int)&#125;</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateDtToFit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> viewStart, <span class="hljs-keyword">int</span> viewEnd, <span class="hljs-keyword">int</span> boxStart, <span class="hljs-keyword">int</span> boxEnd, <span class="hljs-keyword">int</span></span></span><br><span class="hljs-function"><span class="hljs-params">           snapPreference)</span> </span>&#123;<br>       <span class="hljs-keyword">switch</span> (snapPreference) &#123;<br>           <span class="hljs-keyword">case</span> SNAP_TO_START:<br>               <span class="hljs-keyword">return</span> boxStart - viewStart;<br>           <span class="hljs-keyword">case</span> SNAP_TO_END:<br>               <span class="hljs-keyword">return</span> boxEnd - viewEnd;<br>           <span class="hljs-keyword">case</span> SNAP_TO_ANY:<br>               <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dtStart = boxStart - viewStart;<br>               <span class="hljs-keyword">if</span> (dtStart &gt; <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">return</span> dtStart;<br>               &#125;<br>               <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dtEnd = boxEnd - viewEnd;<br>               <span class="hljs-keyword">if</span> (dtEnd &lt; <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-keyword">return</span> dtEnd;<br>               &#125;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">default</span>:<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;snap preference should be one of the&quot;</span><br>                       + <span class="hljs-string">&quot; constants defined in SmoothScroller, starting with SNAP_&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>写一个类继承LinearSmoothScroller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopSmoothScroller</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinearSmoothScroller</span> </span>&#123;<br>    TopSmoothScroller(Context context) &#123;<br>        <span class="hljs-keyword">super</span>(context);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHorizontalSnapPreference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SNAP_TO_START;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVerticalSnapPreference</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SNAP_TO_START;  <span class="hljs-comment">// 将子view与父view顶部对齐</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">float</span> <span class="hljs-title">calculateSpeedPerPixel</span><span class="hljs-params">(DisplayMetrics displayMetrics)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">25.0F</span> / (<span class="hljs-keyword">float</span>) displayMetrics.densityDpi) * <span class="hljs-number">3.5F</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>calculateSpeedPerPixel方法可以设置滚动速度。</p><p>在Activity中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> TopSmoothScroller mTopScroller = <span class="hljs-keyword">new</span> TopSmoothScroller(<span class="hljs-keyword">this</span>);<br>mTopScroller.setTargetPosition(position);<br>mRecyclerView.getLayoutManager.startSmoothScroll(mTopScroller);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android 5.0</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>RecyclerView</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
